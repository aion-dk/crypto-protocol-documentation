\clearpage
\subsection{Pedersen commitment scheme}
A \textit{commitment scheme} consists of a tuple of algorithms ($\mathsf{Com}$, $\mathsf{ComVer}$) that enables a writer to commit to a specific message $m$ while keeping it secret. At a later point, if appropriate, the writer has the ability to open the commitment and reveal the committed message $m$. The \textit{Pedersen Commitment Scheme} is a randomized commitment scheme introduced in \cite{Pedersen91-commitment}. Later, the scheme has been updated in \cite{Bootle18} to enable commitment computation on a list of messages $\boldsymbol{m} = \{m_1, ..., m_n\}$, where each $m_i \in \mathbb{Z}_q$, with $i \in \{1, ..., n\}$.

An important part of the commitment scheme is the existence of multiple generators (one for each message in the list  $\boldsymbol{m}$) in the subgroup such that the discrete logarithm amongst any two of them is unknown. To support that, we define the algorithm $\mathsf{BaseGen}$ that outputs a new generator $H$ such that the value $x$ is unknown where $H = [x]G$.

In order to commit to messages $\boldsymbol{m} = \{m_1, ..., m_n\}$ a writer computes the commitment $C \gets \mathsf{Com}(\boldsymbol{m}; r)$ (\cref{alg: com}), where $r \in_\mathrm{R} \mathbb{Z}_q$ is a randomizer. Algorithm $\mathsf{Com}$ computes internally a list of generators $\boldsymbol{G} = \{G_1, ..., G_n\}$ where each $G_i \gets \mathsf{BaseGen}(i)$ (\cref{alg: base gen}), with $i \in \{1, ..., n\}$.

In order to reveal messages $\boldsymbol{m}$, the writer needs to publish values $\boldsymbol{m}$ and $r$. A verifier is convinced that the commitment $C$ opens to messages $\boldsymbol{m}$ by running $b \gets \mathsf{ComVer}(C, \boldsymbol{m}; r)$ (\cref{alg: com ver}).

\begin{algorithm}[ht]
    \DontPrintSemicolon
    \caption{$\mathsf{BaseGen} (i)$}
    \KwData{An index $i \in \mathbb{N}$}
    
    $x \gets \mathcal{H}(G || i)$ \\
    \Repeat{$H$ is valid}{
        $y \gets \mathsf{RecoverY}(x)$ \tcp*{according to elliptic curve equation}
        \If{$y$ is invalid}{
            $x \gets x + 1$ \;
            \Continue \;
        }
        $H \gets (x, y)$ \;
        \If{$H$ is invalid}{
            $x \gets x + 1$ \;
            \Continue \;
        }
    }
    \Return{$H$} \tcp*{$H \in \mathbb{P}$}
    
    \label{alg: base gen}
\end{algorithm}

\begin{algorithm}[ht]
    \DontPrintSemicolon
    \caption{$\mathsf{Com} (\boldsymbol{m}; r)$}
    \KwData{The list of messages $\boldsymbol{m} = \{m_1, ..., m_n\} \in \mathbb{Z}_q^n$}
    \KwMoreData{The randomizer $r \in \mathbb{Z}_q$}
    
    \For{$i \gets 1$ \KwTo $n$ \KwBy $1$}{
        $G_i \gets \mathsf{BaseGen} (i)$
    }
    $C \gets [r]G + \sum\limits_{i=1}^n [m_i]G_i$ \;
    
    \Return{$C$} \tcp*{$C \in \mathbb{P}$}
    
    \label{alg: com}
\end{algorithm}

\begin{algorithm}[ht]
    \DontPrintSemicolon
    \caption{$\mathsf{ComVer} (C, \boldsymbol{m}; r)$}
    \KwData{The commitment $C \in \mathbb{P}$}
    \KwMoreData{The list of messages $\boldsymbol{m} = \{m_1, ..., m_n\} \in \mathbb{Z}_q^n$}
    \KwMoreData{The randomizer $r \in \mathbb{Z}_q$}
    
    \For{$i \gets 1$ \KwTo $n$ \KwBy $1$}{
        $G_i \gets \mathsf{BaseGen} (i)$
    }
    \eIf{$C = [r]G + \sum\limits_{i=1}^n [m_i]G_i$}{
        $b \gets 1$ \tcp*{commitment is valid}
        }{
        $b \gets 0$ \tcp*{commitment is invalid}
        }
    \Return{$b$} \tcp*{$b \in \mathbb{B}$}
    
    \label{alg: com ver}
\end{algorithm}
