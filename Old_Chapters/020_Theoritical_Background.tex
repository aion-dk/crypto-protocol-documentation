\section{Theoretical Background}

\subsection{Mathematics}

\subsubsection{Group}
In mathematics, a group \( \mathcal{G} = (\mathbb{G}, \circ, \mathrm{inv}, e) \) is an algebraic structure consisting of a set $\mathbb{G}$ of elements, a binary operation indicated by symbol \( \circ \), a unary operation called $\mathbf{inv}$ and a neutral element \( e \in \mathbb{G} \). The following properties must be satisfied by $\mathcal{G}$:

\begin{center}
\begin{tabular}{ l l }
 \textbf{closure} & \( x \circ y \in \mathbb{G} \) \\ 
 \textbf{associativity} & \( x \circ (y \circ z) = (x \circ y) \circ z \) \\  
 \textbf{identity element} & \( x \circ e = e \circ x = x \)  \\
 \textbf{inverse element} & \( x \circ \mathbf{inv}(x) = e \)
\end{tabular}
\end{center}
for all \( x, y, z \in \mathbb{G} \).

If $\mathcal{G}$ has a fifth property called \textit{commutativity} (\( x \circ y = y \circ x \)), then $\mathcal{G}$ is an \textit{abelian group}. 

Moreover, if $\mathcal{G}$ is a \textit{finite group}, then $\mathbb{G}$ has a finite number of elements and we denote \( q = |\mathbb{G}| \) as the order of the group. For example, a finite group would be \( (\mathbb{Z}_q, +, -, 0) \), where \( \mathbb{Z}_q  = \{0, 1, ..., q-1\} \), the binary operation is addition modulo $q$, the inverse operation is negation and the identity element is 0.

The binary operation can be applied on the same element, namely \( x \circ x = [2]x \). We define $[k]x$ as the operation $\circ$ applied $k$ times on the element $x$. 

A finite group \( \mathcal{G} = (\mathbb{G}, \circ, \mathrm{inv}, e) \) of order $q$ is called \textit{cyclic group}, if there is a group element \( g \in \mathbb{G} \), such that \( \mathbb{G} = (g, [2]g, [3]g, ..., [q]g) \). In this case, the element $g$ is called the \textit{generator} of $\mathcal{G}$.

\subsubsection{Finite Field}
A field \( \mathcal{F} = (\mathbb{F}, +, \cdot) \) consists of a set $\mathbb{F}$ which is an abelian group in respect to both operations: addition and multiplication. The following properties hold:
\begin{itemize}
    \item \( x + y \in \mathbb{F} \) and \( x \cdot y \in \mathbb{F} \)
    \item \( (\mathbb{F}, +, -, 0) \) is an abelian group
    \item \( (\mathbb{F}^*, \cdot, ^{-1}, 1) \) is an abelian group
    \item multiplication is distributive over addition: \( x \cdot (y + z) = x \cdot y + x \cdot z \)
\end{itemize}
for all \( x, y, z \in \mathbb{F} \).

A finite field is a filed with a finite number of elements, for example the set of integers modulo $p$, denoted $\mathbb{F}_p$, where $p$ is a prime number.



\subsection{Elliptic Curve}

\subsubsection{Elliptic Curve over a Prime Field}
We define the elliptic curve $E$ over the prime field $\mathbb{F}_p$ as the set of points
\[
    E(\mathbb{F}_p) = \{(x, y) \in (\mathbb{F}_p)^2 \mid y^2 = x^3 + ax + b \pmod p \} \cup \{ \mathcal{O} \}
\]
% \begin{multline}
% E(\mathbb{F}_p) = \{(x, y) \in (\mathbb{F}_p)^2 \mid y^2 = x^3 + ax + b \pmod p, \\
% 4a^3 + 27b^2 \neq 0 \pmod p \} \cup \{ \mathcal{O} \}
% \end{multline}
where a tuple \( (x, y) \) represent the coordinates of a point, \( \mathcal{O} = (0, 0) \) is the point at infinity and \( a, b \in \mathbb{F}_p \).

% The requirement \( 4a^3 + 27b^2 \neq 0 \) that $E$ is non-singular, this means in particular that one may compute the tangent in every point on the curve.

The elliptic curve $E(\mathbb{F}_p)$ follows a group structure with the following rules:
\begin{itemize}
    \item $\mathcal{O}$ is the identity element, thus \( P + \mathcal{O} = \mathcal{O} + P = P \) for all \( P \in E(\mathbb{F}_p) \).
    \item The inverse operations is point negation, noted $-$. For all \( P = (x_P, y_P) \in E(\mathbb{F}_p) \), we define \( -P = (x_P, -y_P) \) such that \( P + (- P) = \mathcal{O} \).
    \item The binary operation is point addition, noted $+$. Let \( P, Q \in E(\mathbb{F}_p) \). The line through $P$ and $Q$ intersects the elliptic curve in a third point \( R = (x_R, y_R) \in E(\mathbb{F}_p) \). The point addition is defined as \( P + Q = -R \). The coordinates of $R$ can be computed in the following way:
    \begin{align*}
        x_R & = \lambda^2 - x_P - x_Q \pmod{p} \\
        y_R & = y_P + \lambda (x_R - x_P) \pmod p 
    \end{align*}
    where $\lambda$ is the steep of line $PQ$. The steep can be computed in the following way:
    \[ \lambda = 
    \begin{cases}
        (y_P - y_Q)(x_P - x_Q)^{-1} \pmod{p} & \text{, if } P \neq Q \\
        (3x_P^2 + a)(2y_P)^{-1} \pmod{p} & \text{, if } P = Q
    \end{cases}
    \]
\end{itemize}

We define the total number of point on the $E(\mathbb{F}_p)$ as $N$ and it can be calculated using \textit{Schoof's algorithm} \cite{Schoof85}. Any subgroup of $E(\mathbb{F}_p)$ has an order $q$ which is a divisor of $N$. In such a case, we define the \textit{cofactor} of the subgroup as \( h = \frac{N}{q} \). To find any generator of the subgroup we follow:
\begin{itemize}
    \item Choose a random point \( P \in E(\mathbb{F}_p) \).
    \item Compute \( G = [h]P \).
    \item If \( G = \mathcal{O} \), repeat the process. Otherwise, $G$ is a generator.
\end{itemize}

In conclusion, we can define our cryptographic cyclic subgroup as:
\[ \mathcal{G} = \{ P \in E(\mathbb{F}_p) \mid P = [k]G, k \in \mathbb{Z}_q \} \]
where $G$ is the generator and $q$ is the order of the subgroup. We call the integer $k$ a \textit{scalar}.

\subsubsection{Elliptic Curve Discrete Logarithm Problem}
The \textit{Elliptic Curve Discrete Logarithm Problem} is defined in \cite{Trappe05} the following way: Given the elliptic curve domain parameters \( (p, a, b, G, q, h) \) and a point \( P \in \mathcal{G} \), find the scalar \( k \in \mathbb{Z}_p \) such that \( P = [k]G \). For an elliptic curve to be cryptographically strong, the ECDLP has to be \textit{computationally infeasible}.

\subsubsection{Supported Eliptic Curves}
The following cryptosystems are supported by AVX:

\paragraph{Secp256k1(Bitcoin Curve)}

%For our cryptosystem we will use a predefined elliptic curve called \textit{secp256k1}, also known as the \textit{Bitcoin Curve} with the following domain parameters:
The redefined elliptic curve called \textit{secp256k1}, also known as the \textit{Bitcoin Curve} is supported with the following domain parameters:
\begin{center}
\begin{tabular}{ | l | l | }
    \hline
    % \textbf{Parameter} & \textbf{Value} \\ \hline
    $p$ & \footnotesize \texttt{ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f} \\ \hline
    $a$ & \footnotesize \texttt{0} \\ \hline
    $b$ & \footnotesize \texttt{7} \\ \hline
    $G.x$ & \footnotesize \texttt{79be667e f9dcbbac 55a06295 ce870b07 029bfcdb 2dce28d9 59f2815b 16f81798} \\ \hline
    $G.y$ & \footnotesize \texttt{483ada77 26a3c465 5da4fbfc 0e1108a8 fd17b448 a6855419 9c47d08f fb10d4b8} \\ \hline
    $q$ & \footnotesize \texttt{ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141} \\ \hline
    $h$ & \footnotesize \texttt{1} \\ \hline
\end{tabular}
\end{center}

The equation of the elliptic curve is \( y^2 = x^3 + 7 \). The cofactor of the curve is 1, that means any point on the curve is part of our cyclic subgroup as well. We assume the Elliptic Curve Discrete Logarithm Problem to be hard in respect to the \textit{secp256k1}. We will reffer to this as the \textit{discrete logarithm assumption}.

\paragraph{Supported cryptosystem \#2}

\paragraph{Supported cryptosystem \#3}

\subsubsection{Elliptic Curve Point Encoding}
Each point on the curve is represented by its $x$ and $y$ coordinate. As presented in section \ref{elliptic curve}, the $y$ coordinate can be calculated based on the $x$ coordinate, but there would be two possible values for it. Thus, one extra bit of information is required specifying which of the two values is to be used.

An elliptic curve point can be represented as byte array in two ways: \textit{compressed form} or \textit{uncompressed form}. The compressed form contains the byte representation of only the $x$ coordinate to which is prepended a byte, 02 or 03 depending on which value to choose for the $y$ coordinate. The uncompressed form contains the byte representation of both $x$ and $y$ coordinates concatenated together, to which is prepended the byte 04.

In our system, when an elliptic curve point has to be stored in the database, or when it needs to be transferred over the network, or when it is used as input to a hash function, it is represented as byte array in compressed form.

\subsubsection{Mapping a message on the Elliptic Curve}
An important use case of a cryptographic system is to be able to interpret an arbitrary message (a plain text, a number, an id or even a more complex construction). In elliptic curve context, that means mapping a message into an elliptic curve point in a deterministic way. Additionally, this curve point must be able to be interpreted back as the original message.

We use the algorithm \( M \gets \mathbf{String2Point}(m) \) (algorithm \ref{alg: string to point}), presented in \cite{Trappe05}, that can map a plain text \( m \in \mathbb{C}^* \) to an elliptic curve point \( M \in E(\mathbb{F}_p) \), where $\mathbb{C}$ is the set of all possible one byte UTF-8 text characters. The byte representation of message $m$ is converted into a large integer $m_\mathrm{BN}$, called \textit{BigNum}, and used in the calculation of the $x$ coordinate of the point $M$, while the $y$ coordinate is computed using the equation of the elliptic curve \( y \gets \mathbf{RecoverY(x)} \). Note that the elliptic curve equation might spawn no valid values for $y$ or two values for $y$. In case $y$ is not valid, it means $x$ is not a valid coordinate to generate a point, otherwise, the algorithm randomly chooses one of the two value for $y$ and continues.

The $x$ coordinate is computed by multiplying $m_\mathrm{BN}$ with 256, in order to use the right most byte as an \textit{adjusting byte} in case the $x$ coordinate does not correspond to a valid point on the curve, i.e. we keep incrementing $x$ until we find a valid $y$. To ensure that $x$ is less than the prime of the curve $p$ we introduce the condition that $m$ can be at most 30 characters in length.

By having one \textit{byte space} to find a valid point on the curve, we know from \cite{Trappe05} that the probability that all 256 $x$ coordinates generate invalid points is $1/2^{256}$, which we consider acceptable. Formally, the algorithm $\mathbf{String2Point}$ converts an arbitrary text of maximum 30 characters in length into a valid point on the elliptic curve with negligible failure rate.

\begin{algorithm}[!h]
\DontPrintSemicolon
    \caption{\( \mathbf{String2Point} (m) \)}
    \KwData{The message \( m = (c_1, ..., c_\ell) \in \mathbb{C}^* \)}
    \If{\( \ell > 30 \)}{
        \Return{failure}
        }
    \( \boldsymbol{b} = (b_1, ..., b_\ell) \gets \mathbf{ByteRepresentationOf} (m) \) \;
    \( m_\mathrm{BN} \gets \mathbf{Bytes2BigNum} (\boldsymbol{b}) \) \;
    \( x_0 \gets m_\mathrm{BN} \cdot 256 \) \;
    \For{\( i \gets 0 \) \KwTo $255$ \KwBy $1$}{
        \( x \gets x_0 + i \) \;
        \( y \gets \mathbf{RecoverY}(x) \) \tcp*{\( y^2 = x^3 + 7 \)}
        \( M \gets (x, y) \) \;
        \If{$M$ is valid}{
            \Return{\( M \)} \tcp*{\( M \in E(\mathbb{F}_p) \)}
            }
        }
    \Return{failure}
\end{algorithm}

Recovering the text message $m$ from an elliptic curve point $M$ can be done
by calling \( m \gets \mathbf{Point2String}(M) \) (algorithm \ref{alg: point to string}). The algorithm tries to interpret as text the byte representation of the $x$ coordinate, disregarding the \textit{adjusting byte} (the right most byte). In case this fails, the algorithm returns a failure state, meaning that point $M$ does not encode a text message.

\newpage
Having these two algorithms, mapping a message on the Elliptic Curve is a sound procedure as
\[ m = \mathbf{Point2String}(\mathbf{String2Point}(m)) \text{ , for all \( m \in \mathbb{C}^* \), with \( |m| \leq 30 \).} \]

\begin{algorithm}[!h]
\DontPrintSemicolon
    \caption{\( \mathbf{Point2String} (M) \)}
    \KwData{The point \( M = (x, y) \in E(\mathbb{F}_p) = \mathbb{Z}_p \times \mathbb{Z}_p \)}
    \( m_\mathrm{BN} \gets x / 256 \) \tcp*{disregard the \textit{adjusting byte}}
    \( \boldsymbol{b} = (b_1, ..., b_\ell) \gets \mathbf{ByteRepresentationOf} (m_\mathrm{BN}) \) \;

    \For{\( i \gets 1 \) \KwTo $\ell$ \KwBy $1$}{
        \( c_i \gets \mathbf{Byte2Char} (b_i) \)}
    
    \eIf{ all \( c_i \in \mathbb{C} \)}{
        \( m = (c_1, ..., c_\ell) \) }{
        \Return{failure}}

    \Return{\( m \)} \tcp*{\( m \in \mathbb{C}^* \)}
\end{algorithm}

\subsection{Zero Knowledge Proofs}
A \textit{zero knowledge proof} (ZKP) is an algorithm by which one party (the \textit{prover}) can prove to another party (the \textit{verifier}) that she knows a secret value $x$, without disclosing any information about $x$. A ZKP can be \textit{interactive}, where the prover and the verifier have to collaborate in a protocol for the verifier to get convinced of the proof. A ZKP can also be \textit{non-interactive}. In this case, the prover alone generates a proof that is publicly verifiable, thus convincing any public verifier of its statement. 

There exists two algorithms \textbf{Prove} for generating a proof and \textbf{Verify} for verifying whether a proof validates. A classic proof has a structure of a triple (commitment, challenge and response). In an interactive zero knowledge protocol, a prover commits to a value, the verifier independently and randomly generates a challenge, the prover computes a response based on the challenge received and the verifier checks that the proof validates. The proof can be turned into a non-interactive one, using the \textit{Fiat-Shamir heuristic} as described in \cite{Fiat87}. The prover computes alone the challenge, in a deterministic manner, based on the commitment, using a hash function.

\subsubsection{Discrete Logarithm Proof}
A simple kind of ZKP is the \textit{discrete logarithm proof} that proves knowledge of value $x$, such that \( Y = [x]G \), formally
\[
PK[(x) : Y = [x]G]
\]
The most intuitive application of this could be to prove the possession of the private key associated with a public key. In order to prove such a fact, a prover and a verifier have to interact in the protocol described in figure \ref{fig:DL_protocol}. The resulting proof would be \( PK = (K, c, r) \).

% \begin{algorithm}[H]
% \floatname{algorithm}{Prove}
% \renewcommand{\thealgorithm}{}
% \caption{Protocol for generating a discrete logarithm interactive ZKP}
% \begin{algorithmic}[1]
% \STATE Prover : Picks random value \( k \in_R \mathbb{Z}_q \) and sends the commitment \( K = [k]G \) to the verifier.
% \STATE Verifier : Picks a random challenge \( c \in_R \mathbb{Z}_q \) and sends it to the prover.
% \STATE Prover : Computes the response \( r = k + c \cdot x \pmod q \) and sends it to the verifier.
% \end{algorithmic}
% \end{algorithm} 

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[framed]
        \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
            \textbf{Prover} & & \textbf{Verifier} \\
            /*knows $x$*/ & & \\ [2mm]
            \scriptsize /*pick random scalar*/ & & \\ [-1mm]
            \( k \in_\mathrm{R} \mathbb{Z}_q \) & & \\ [2mm]
            \scriptsize /*compute commitment*/ & & \\ [-1mm]
            \( K \gets [k]G \) & & \\
            & send $K$ & \\ [1mm]
            & & \scriptsize /*pick random challenge*/ \\ [-1mm]
            & & \( c \in_\mathrm{R} \mathbb{Z}_q \) \\
            & send $c$ & \\
            \scriptsize /*compute response*/ & & \\ [-1mm]
            \( r \gets k + c \cdot x \pmod q \) & & \\
            & send $r$ & \\ [1mm]
            & & \scriptsize /*verify proof*/ \\ [-1mm]
            & & \( [r]G \stackrel{?}{=} K + [c]Y \) \\
        };
        
        \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
        \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
        \draw[-latex] (m-7-2.south west)--(m-7-2.south east);
        \draw[-latex] (m-10-2.south east)--(m-10-2.south west);
        \draw[-latex] (m-13-2.south west)--(m-13-2.south east);
    \end{tikzpicture}
    \caption{Protocol for proving the discrete logarithm}
\end{figure}

To generate a \textit{non-interactive proof}, the protocol from figure \ref{fig:DLE_protocol} is turned into two distinct algorithms: one for generating a proof \( PK \leftarrow \mathbf{Prove}_G (x) \) (algorithm \ref{alg: Prove dl}) and another one for validating whether a proof validates \( b \leftarrow \mathbf{Verify}_G (PK, Y) \) (algorithm \ref{alg: Verify dl}) that outputs a bit \( b \in \mathbb{B} \) which represents $true$ or $false$. The prover generates a commitment, then computes the challenge of the proof, based on that commitment, using a hash function, and finally, computes the response of the proof. The prover publishes the proof, which is universally verifiable. Any public verifier can check whether the proof validates.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{Prove}_G (x) \)}
    \KwData{The base generator \( G \in E(\mathbb{F}_p) \)}
    \myinput{The private key \( x \in \mathbb{Z}_q \)}
    \( k \in_\mathrm{R} \mathbb{Z}_q \)\;
    \( K \gets [k]G \)\;
    \( Y \gets [x]G \)\;
    \( c \gets \mathcal{H}(G || K || Y) \) \tcp*{compute challenge by hash function}
    \( r \gets k + c \cdot x \pmod q \)\;
    \( PK \gets (K, c, r) \)\;
    \Return{$PK$} \tcp*{\( PK \in E(\mathbb{F}_p) \times \mathbb{Z}_q \times \mathbb{Z}_q \)}
\end{algorithm}
% \end{figure}

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{Verify}_G (PK, Y) \)}
    \KwData{The base generator \( G \in E(\mathbb{F}_p) \)}
    \myinput{The proof \( PK = (K, c, r) \in E(\mathbb{F}_p) \times \mathbb{Z}_q \times \mathbb{Z}_q \)}
    \myinput{The public key \( Y \in E(\mathbb{F}_p) \)}
    \eIf{\( c = \mathcal{H}(G || K || Y) \) \KwAnd \( [r]G = K + [c]Y \)}{
        \( b \gets 1 \) \tcp*{proof is valid}
        }{
        \( b \gets 0 \) \tcp*{proof is invalid}
        }
    \Return{$b$} \tcp*{\( b \in \mathbb{B} \)}
\end{algorithm}
% \end{figure}

% To verify the proof $PK$, the verifier runs the verification algorithm \( b \leftarrow \mathbf{Verify}_G (PK, Y) \) that outputs $true$ or $false$ (\( b \in \mathbb{B} \)) depending on whether the following equation holds:
% \[
% [r]G = K + [c]Y.
% \]

% To turn the proof above in a non-interactive one, the prover simply computes the value of the challenge by \( c = \mathcal{H}(G || K || Y) \). Now the proof is universally verifiable, but any verifier has to, additionally, check that the challenge is computed correctly.

\subsubsection{Discrete Logarithm Equality Proof}
A bit more complex ZKP is the \textit{discrete logarithm equality proof} that proves that two different elliptic curve points \( Y, P \in E(\mathbb{F}_p) \) have the same elliptic curve discrete logarithm \( x \in \mathbb{Z}_q \) in regards to two distinct generators \( G, H \in E(\mathbb{F}_p) \).
\[
PK[(x) : Y = [x]G \wedge P = [x]H]
\]

The proof has the same structure as in previous section \( PK = (\boldsymbol{K}, c, r) \), but here the commitment \( \boldsymbol{K} = (K_\mathrm{G}, K_\mathrm{H}) \) is a tuple of points, one for each generator that the proof is based on. The updated protocol for proving the discrete logarithm equality is described in figure \ref{fig:DLE_protocol}.

% \begin{algorithm}[H]
% \floatname{algorithm}{Prove}
% \renewcommand{\thealgorithm}{}
% \caption{Protocol for generating a discrete logarithm equality interactive ZKP}
% \begin{algorithmic}[1]
% \STATE Prover : Picks random value \( k \in_R \mathbb{Z}_q \) and computes \( K_\mathrm{G} = [k]G \) and \( K_\mathrm{H} = [k]H \). Prover sends commitment \( \boldsymbol{K} = (K_\mathrm{G}, K_\mathrm{H}) \) to the verifier.
% \STATE Verifier : Picks a random challenge \( c \in_R \mathbb{Z}_q \) and sends it to the prover.
% \STATE Prover : Computes the response \( r = k + c \cdot x \pmod q \) and sends it to the verifier.
% \end{algorithmic}
% \end{algorithm} 

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[framed]
        \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
            \textbf{Prover} & & \textbf{Verifier} \\
            /*knows $x$*/ & & \\ [2mm]
            \scriptsize /*pick random scalar*/ & & \\ [-1mm]
            \( k \in_\mathrm{R} \mathbb{Z}_q \) & & \\ [2mm]
            \scriptsize /*compute commitment*/ & & \\ [-1mm]
            \( K_\mathrm{G} \gets [k]G \) & & \\
            \( K_\mathrm{H} \gets [k]H \) & & \\
            \( \boldsymbol{K} \gets (K_\mathrm{G}, K_\mathrm{H}) \) & & \\
            & send $\boldsymbol{K}$ & \\ [1mm]
            & & \scriptsize /*pick random challenge*/ \\ [-1mm]
            & & \( c \in_\mathrm{R} \mathbb{Z}_q \) \\
            & send $c$ & \\
            \scriptsize /*compute response*/ & & \\ [-1mm]
            \( r \gets k + c \cdot x \pmod q \) & & \\
            & send $r$ & \\ [1mm]
            & & \scriptsize /*verify proof*/\\ [-1mm]
            & & \( [r]G \stackrel{?}{=} K_\mathrm{G} + [c]Y \) \\
            & & \( [r]H \stackrel{?}{=} K_\mathrm{H} + [c]P \) \\
        };
        
        \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
        \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
        \draw[-latex] (m-9-2.south west)--(m-9-2.south east);
        \draw[-latex] (m-12-2.south east)--(m-12-2.south west);
        \draw[-latex] (m-15-2.south west)--(m-15-2.south east);
    \end{tikzpicture}
    \caption{Protocol for proving the discrete logarithm equality}
\end{figure}

Again, to generate the discrete logarithm equality proof in a \textit{non-interactive} manner, we turn the protocol into two algorithms: one for generating the proof \( PK \leftarrow \mathbf{ProveEquality}_{G, H} (x) \) (algorithm \ref{alg: Prove dle}) and another one for validating a proof \( b \leftarrow \mathbf{VerifyEquality}_{G, H} (PK, Y, P) \) (algorithm \ref{alg: Verify dle}), where \( b \in \mathbb{B} \) represents \textit{true} or \textit{false}. In this case, proof $PK$ is universally verifiable and can be audited by any public verifier.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{ProveEquality}_{G, H} (x) \)}
    \KwData{The first base generator \( G \in E(\mathbb{F}_p) \)}
    \myinput{The second base generator \( H \in E(\mathbb{F}_p) \)}
    \myinput{The private key \( x \in \mathbb{Z}_q \)}
    \( k \in_\mathrm{R} \mathbb{Z}_q \)\;
    \( K_\mathrm{G} \gets [k]G \)\;
    \( K_\mathrm{H} \gets [k]H \)\;
    \( \boldsymbol{K} \gets (K_\mathrm{G}, K_\mathrm{H}) \)\;
    % \( Y \gets [x]G \)\;
    % \( P \gets [x]H \)\;
    \( c \gets \mathcal{H}(G || H || K_\mathrm{G} || K_\mathrm{H} || Y || P) \) \tcp*{\( Y = [x]G \), \( P = [x]H \)}
    \( r \gets k + c \cdot x \pmod q \)\;
    \( PK \gets (\boldsymbol{K}, c, r) \)\;
    \Return{$PK$} \tcp*{\( PK \in E(\mathbb{F}_p)^2 \times \mathbb{Z}_q \times \mathbb{Z}_q \)}
\end{algorithm}
% \end{figure}

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{VerifyEquality}_{G, H} (PK, Y, P) \)}
    \KwData{The first base generator \( G \in E(\mathbb{F}_p) \)}
    \myinput{The second base generator \( H \in E(\mathbb{F}_p) \)}
    \myinput{The proof \( PK = (\boldsymbol{K}, c, r) \in E(\mathbb{F}_p)^2 \times \mathbb{Z}_q \times \mathbb{Z}_q \)}
    \myinput{The first public key \( Y \in E(\mathbb{F}_p) \)}
    \myinput{The second public key \( P \in E(\mathbb{F}_p) \)}
    \eIf{\( c = \mathcal{H}(G || H || K_\mathrm{G} || K_\mathrm{H} || Y || P) \) \\ \KwAnd \( [r]G = K_\mathrm{G} + [c]Y \) \\ \KwAnd \( [r]H = K_\mathrm{H} + [c]P \)}{
        \( b \gets 1 \) \tcp*{proof is valid}
        }{
        \( b \gets 0 \) \tcp*{proof is invalid}
        }
    \Return{$b$} \tcp*{\( b \in \mathbb{B} \)}
\end{algorithm}
% \end{figure}

% To verify a proof $PK$ now, the verification algorithm \( \mathbf{Verify}_{G, H} (PK, Y, P) \) has to check all equations, one for each generator that the proof is based on:

% \[
% [r]G = K_\mathrm{G} + [c]Y
% \]
% \[
% [r]H = K_\mathrm{H} + [c]P
% \]

% To make the proof non-interactive, the challenge is computed the following way \( c = \mathcal{H} (G || H || K_\mathrm{G} || K_\mathrm{H} || Y || P) \). 

\clearpage
\subsubsection{Proof for Multiple Discrete Logarithms}
An optimization in proving the discrete logarithm equality between multiple points in regards to their generators has been described in \cite{Chow10}. Using the optimized algorithm for proving that
\[
PK[(x) : \bigwedge_{i=0}^{n} Y_i = [x]G_i]
\]
we generate the proof \( PK = (K, c, r) \) by following the protocol described in figure \ref{fig:DLM_protocol}. The optimization consists in the fact that the commitment $K$ is just one point instead of a list of points, regardless of the value of $n$.

% \begin{algorithm}[H]
% \floatname{algorithm}{Prove}
% \renewcommand{\thealgorithm}{}
% \caption{Protocol for generating a discrete logarithm equality interactive ZKP}
% \begin{algorithmic}[1]
% \STATE Prover : Picks random value \( k \in_R \mathbb{Z}_q \) and computes values \( z_i = \mathcal{H} (i || h) \), where \( h = \mathcal{H} (Y_1 || ... || Y_n) \) and \( i \in \{ 1, ..., n \} \). Prover sends to the verifier commitment \( K = [k] (G_0 + \sum_{i=1}^n [z_i]G_i) \).
% \STATE Verifier : Picks a random challenge \( c \in_R \mathbb{Z}_q \) and sends it to the prover.
% \STATE Prover : Computes the response \( r = k + c \cdot x \pmod q \) and sends it to the verifier.
% \end{algorithmic}
% \end{algorithm} 

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[framed]
        \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
            \textbf{Prover} & & \textbf{Verifier} \\
            /*knows $x$*/ & & \\ [2mm]
            \scriptsize /*pick random scalar*/ & & \\ [-1mm]
            \( k \in_\mathrm{R} \mathbb{Z}_q \) & & \\ [2mm]
            \scriptsize /*compute scalars*/ & & \\ [-1mm]
            \( h \gets \mathcal{H} (Y_1 || ... || Y_n) \) & & \\
            \( z_i \gets \mathcal{H} (i || h) \), \( i \in \{ 1, ..., n \} \) & & \\ [2mm]
            \scriptsize /*compute commitment*/ & & \\ [-1mm]
            \( K \gets [k](G_0 + \sum_{i=1}^n [z_i]G_i) \) & & \\
            & send $K$ & \\
            & & \scriptsize /*pick random challenge*/ \\ [-1mm]
            & & \( c \in_\mathrm{R} \mathbb{Z}_q \) \\
            & send $c$ & \\
            \scriptsize /*compute response*/ & & \\ [-1mm]
            \( r \gets k + c \cdot x \pmod q \) & & \\
            & send $r$ & \\
            & & \scriptsize /*compute scalars*/ \\ [-1mm]
            & & \( h = \mathcal{H} (Y_1 || ... || Y_n) \) \\
            & & \( z_i = \mathcal{H} (i || h) \), \( i \in \{ 1, ..., n \} \) \\ [2mm]
            & & \scriptsize /*verify proof*/ \\ [-1mm]
            & & \( [r](G_0 + \sum_{i=1}^n ([z_i]G_i)) \) \\
            & & \(\stackrel{?}{=} K + [c](Y_0 + \sum_{i=1}^n ([z_i]Y_i)) \) \\
        };
        
        \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
        \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
        \draw[-latex] (m-10-2.south west)--(m-10-2.south east);
        \draw[-latex] (m-13-2.south east)--(m-13-2.south west);
        \draw[-latex] (m-16-2.south west)--(m-16-2.south east);
    \end{tikzpicture}
    \caption{Protocol for proving multiple discrete logarithms}
\end{figure}

The same as in the discrete logarithm equality case, the proof of multiple discrete logarithms can be turned into an non-interactive one by computing the challenge of the proof based on the commitment, using a hash function. The proof is generated by the algorithm \( PK \leftarrow \mathbf{ProveMultiple}_{\boldsymbol{G}} (x) \) (algorithm \ref{alg: Prove dlm}), where \( \boldsymbol{G} = (G_0, ... G_n) \) is the list of generators.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{ProveMultiple}_{\boldsymbol{G}} (x) \)}
    \KwData{The list of generators \( \boldsymbol{G} = (G_0, G_1, ..., G_n) \in E(\mathbb{F}_p)^{n+1} \)}
    \myinput{The private key \( x \in \mathbb{Z}_q \)}
    \( k \in_\mathrm{R} \mathbb{Z}_q \)\;
    % \For{\( i \gets 1 \) \KwTo $n$ \KwBy $1$}{
    %     \( Y_i \gets [x]G_i \)}
    \( h \gets \mathcal{H} (Y_1 || ... || Y_n) \) \tcp*{\( Y_i = [x]G_i \), \( i \in \{ 1, ..., n \} \)}
    \For{\( i \gets 1 \) \KwTo $n$ \KwBy $1$}{
        \( z_i \gets \mathcal{H} (i || h) \)}
    \( K \gets [k] (G_0 + \sum_{i=1}^n [z_i]G_i) \)\;
    \( c \gets \mathcal{H}(G_0 || ... || G_n || K || Y_0 || ... || Y_n) \) \;
    \( r \gets k + c \cdot x \pmod q \)\;
    \( PK \gets (K, c, r) \)\;
    \Return{$PK$} \tcp*{\( PK \in E(\mathbb{F}_p) \times \mathbb{Z}_q \times \mathbb{Z}_q \)}
\end{algorithm}
% \end{figure}

The verifier accepts the proof if the algorithm $\mathbf{Verify}_{\boldsymbol{G}} (PK, \boldsymbol{Y})$ returns true. The verification algorithm is described in algorithm \ref{alg: Verify dlm}.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{VerifyMultiple}_{\boldsymbol{G}} (PK, \boldsymbol{Y}) \)}
    \KwData{The list of generators \( \boldsymbol{G} = (G_0, G_1, ..., G_n) \in E(\mathbb{F}_p)^{n+1} \)}
    \myinput{The proof \( PK = (K, c, r) \in E(\mathbb{F}_p) \times \mathbb{Z}_q \times \mathbb{Z}_q \)}
    \myinput{The list of public keys \( \boldsymbol{Y} = (Y_0, Y_1, ..., Y_n) \in E(\mathbb{F}_p)^{n+1} \)}
    \( h \gets \mathcal{H} (Y_1 || ... || Y_n) \)\;
    \For{\( i \gets 1 \) \KwTo $n$ \KwBy $1$}{
        \( z_i \gets \mathcal{H} (i || h) \)}
    \eIf{\( c = \mathcal{H}(G_0 || ... || G_n || K || Y_0 || ... || Y_n) \) \\ \KwAnd \( [r](G_0 + \sum_{i=1}^n ([z_i]G_i)) = K + [c](Y_0 + \sum_{i=1}^n ([z_i]Y_i)) \)}{
        \( b \gets 1 \) \tcp*{proof is valid}
        }{
        \( b \gets 0 \) \tcp*{proof is invalid}
        }
    \Return{$b$} \tcp*{\( b \in \mathbb{B} \)}
\end{algorithm}
% \end{figure}

% \[
% [r](G_0 + \sum_{i=1}^n ([z_i]G_i)) = K + [c](Y_0 + \sum_{i=1}^n ([z_i]Y_i))
% \]
% where \( z_i = \mathcal{H} (i || h) \), \( h = \mathcal{H} (Y_1 || ... || Y_n) \) and \( i \in \{1, ..., n\} \).

\subsection{Hash Functions}
A \textit{cryptographic hash function} is an algorithm used for mapping data of arbitrary size to data of fixed size, also called the \textit{hash value}. We define the hash function \( \mathcal{H} : \mathbb{B}^* \rightarrow \mathbb{B}^\ell \), where $\mathbb{B}^\ell$ represents a bit array of length $\ell$. In practice, hash algorithms work on byte arrays instead of bit arrays. Thus, the length of the input or output array is \( \ell/8 \).

The hash value of any kind of data can be computed, for example a string, a number, even an object with a complex structure. The hash value would be the result of the hash function applied on the byte representation of that particular input data. A hash value can be computed of an arbitrary number of inputs at the same time. In such case, the hash function is applied on the concatenation of all byte representation of each input.

A hash function is known as a \textit{one way function}, that means, one can easily verify that some input data maps to a given hash value but, if the input data is unknown, it is infeasible to calculate it given only a hash value. Another property of a cryptographic hash function is \textit{collision resistance}. That means, it is difficult to find two different input data with the same hash values.

In our system, we will use the hash function called \textit{SHA-256} that outputs bit arrays of 256 bits in length (32 byte array).

\subsection{Elgamal Cryptosystem}
The \textit{Elgamal cryptosystem} is an asymmetric, randomized encryption scheme, where anybody can encrypt a message using the encryption key resulting in a \textit{cryptogram}, while only the one in possession of the decryption key can extract the message of a cryptogram. The scheme consists of a triple (\textbf{KeyGen}, \textbf{Enc}, \textbf{Dec}) of algorithms that work on the elliptic curve described in section \ref{ECDLP}. The scheme is considered secure under the \textit{discrete logarithm assumption}.

An Elgamal key pair is a tuple \( (x, Y) \leftarrow \mathbf{KeyGen()} \) (algorithm \ref{alg: key gen}), where $x$ is a randomly chosen scalar representing the private decryption key and $Y$ is an elliptic curve point corresponding to the public encryption key.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{KeyGen} () \)}
    \( x \in_\mathrm{R} \mathbb{Z}_q \)\;
    \( Y \gets [x]G \)\;
    \Return{\( (x, Y) \)} \tcp*{\( (x, Y) \in \mathbb{Z}_q \times E(\mathbb{F}_p) \)}
\end{algorithm}
% \end{figure}

The encryption algorithm \( e = (R, C) \leftarrow \mathbf{Enc}_Y (M, r) \) (algorithm \ref{alg: enc}) can be used by anybody in possession of the encryption key $Y$, to generate a cryptogram on a message $M$, using the randomnizer $r$. The cryptogram $e$ can be decrypted back to the original message $M$, only by the one in possession of the secret decryption key $x$, using the decryption algorithm \( M \leftarrow \mathbf{Dec}_x (e) \) (algorithm \ref{alg: dec}). For convenience of notation, we define \( \mathbb{E} = E(\mathbb{F}_p) \times E(\mathbb{F}_p) \) as the set of all possible cryptograms.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{Enc}_Y (M, r) \)}
    \KwData{The encryption key \( Y \in E(\mathbb{F}_p) \)}
    \myinput{The message \( M \in E(\mathbb{F}_p) \)}
    \myinput{The randomizer \( r \in \mathbb{Z}_q \)}
    \( R \gets [r]G \)\;
    \( S \gets [r]Y \)\;
    \( C \gets S + M \)\;
    \( e \gets (R, C) \)\;
    \Return{\( e \)} \tcp*{\( e \in \mathbb{E} \)}
\end{algorithm}
% \end{figure}

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{Dec}_x (e) \)}
    \KwData{The decryption key \( x \in \mathbb{Z}_q \)}
    \myinput{The cryptogram \( e = (R, C) \in \mathbb{E} \)}
    \( S \gets [x]R \)\;
    \( M \gets C - S \)\;
    \Return{\( M \)} \tcp*{\( M \in E(\mathbb{F}_p) \)}
\end{algorithm}
% \end{figure}

Special encryption and decryption algorithms exist in case the message to be encrypted is not an elliptic curve point but a scalar. An extra step is required for mapping a curve point into a number from $\mathbb{Z}_q$, i.e. hashing the point $S$ to get the integer \( s \in \mathbb{Z}_q \). Formally, the message to be encrypted is \( m \in \mathbb{Z}_q \). The algorithm for encrypting a scalar \( e = (R, c) \leftarrow \mathbf{EncScalar}_Y (m, r) \) is described in algorithm \ref{alg: enc scalar}, while the decryption algorithm \( m \leftarrow \mathbf{DecScalar}_x (e) \) is described in algorithm \ref{alg: dec scalar}.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{EncScalar}_Y (m, r) \)}
    \KwData{The encryption key \( Y \in E(\mathbb{F}_p) \)}
    \myinput{The message \( m \in \mathbb{Z}_q \)}
    \myinput{The randomizer \( r \in \mathbb{Z}_q \)}
    \( R \gets [r]G \)\;
    \( S \gets [r]Y \)\;
    \( s \gets \mathcal{H} (S) \)\;
    \( c \gets s \cdot m \pmod q \)\;
    \( e \gets (R, c) \)\;
    \Return{\( e \)} \tcp*{\( e \in E(\mathbb{F}_p) \times \mathbb{Z}_q \)}
\end{algorithm}
% \end{figure}

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{DecScalar}_x (e) \)}
    \KwData{The decryption key \( x \in \mathbb{Z}_q \)}
    \myinput{The cryptogram \( e = (R, c) \in E(\mathbb{F}_p) \times \mathbb{Z}_q \)}
    \( S \gets [x]R \)\;
    \( s \gets \mathcal{H} (S) \)\;
    \( m \gets c \cdot s^{-1} \pmod q \)\;
    \Return{\( m \)} \tcp*{\( m \in \mathbb{Z}_q \)}
\end{algorithm}
% \end{figure}

% \textbf{Enc} is the encryption algorithm that is used by anybody in possession of the encryption key, to generate a cryptogram on a message. Depending on the type of the message to be encrypted (point or scalar), the encryption algorithm is as follows:
% \begin{itemize}
%     \item Point encryption \( (R, C) \leftarrow \mathbf{Enc}_Y(M, r) \) of the message \( M \in E(\mathbb{F}_p) \) with randomization \( r \in_R \mathbb{Z}_q \)
%     \begin{equation}
%         \begin{split}
%         R & = [r]G \\
%         C & = [r]Y + M
%         \end{split}
%     \end{equation}
    
%     \item Scalar encryption \( (R, c) \leftarrow \mathbf{Enc}_Y(m, r) \) of the message \( m \in \mathbb{Z}_q \) with randomization \( r \in_R \mathbb{Z}_q \)
%     \begin{equation}
%         \begin{split}
%         R & = [r]G \\
%         c & = \mathcal{H}([r]Y) \cdot m \pmod q 
%         \end{split}
%     \end{equation}
%     where \( \mathcal{H}(\cdot) \in \mathbb{Z}_q \) is a hash function.
% \end{itemize}

% \textbf{Dec} is the decryption algorithm that is used by the owner of the decryption key, to extract the message of a cryptogram. Depending on the type of the message to be decrypted (point or scalar), the algorithm is as follows:
% \begin{itemize}
%     \item Point decryption \( M \leftarrow \mathbf{Dec}_x(R, C) \) of the message \( M \in E(\mathbb{F}_p) \)
%     \begin{equation}
%         \begin{split}
%         S & = [x]R \\
%         M & = C - S
%         \end{split}
%     \end{equation}
    
%     \item Scalar decryption \( m \leftarrow \mathbf{Dec}_x(R, c) \) of the message \( m \in \mathbb{Z}_q \)
%     \begin{equation}
%         \begin{split}
%         s & = \mathcal{H}([x]R) \\
%         m & = c \cdot s^{-1} \pmod q 
%         \end{split}
%     \end{equation}
% \end{itemize}

\subsubsection{Proving the Content of a Cryptogram}
Once a cryptogram is generated \( e = (R, C) \leftarrow \mathbf{Enc}_Y (M, r) \), only the \textit{sender} (the one who generated the cryptogram) and the \textit{receiver} (the one in possession of the decryption key $x$) know the value of the message $M$. Both of them have the possibility to prove to somebody else (or publicly prove) the content of the cryptogram.

The one who generated the cryptogram can prove to a verifier that the cryptogram $e$ contains message $M$ by engaging in the protocol from figure \ref{fig:DLE_protocol} in order to prove the knowledge of the randomizer \( PK[(r): R = [r]G \wedge (C - M) = [r]Y] \). To generate a publicly verifiable proof, the \textit{sender} can generate a non-interactive proof \( PK \leftarrow \mathbf{ProveEquality}_{G, Y} (r) \) (algorithm \ref{alg: Prove dle}). Any public verifier is convinced that cryptogram $e$ contains message $M$ if the verification algorithm succeeds \( \mathbf{VerifyEquality}_{G, Y} (PK, R, C - M) \) (algorithm \ref{alg: Verify dle}).

At the same time, the one in possession of the decryption key $x$ can prove the content of the cryptogram $e$ to a verifier by engaging in the same protocol from figure \ref{fig:DLE_protocol} but this time for proving the knowledge of the decryption key \( PK[(x): Y = [x]G \wedge (C - M) = [x]R] \). To generate a publicly verifiable proof, the \textit{receiver} of the cryptogram can generate a non-interactive proof \( PK \leftarrow \mathbf{ProveEquality}_{G, R} (x) \) (algorithm \ref{alg: Prove dle}). Any public verifier is convinced that cryptogram $e$ contains message $M$ if the verification algorithm succeeds \( \mathbf{VerifyEquality}_{G, R} (PK, Y, C - M) \) (algorithm \ref{alg: Verify dle}).

\subsubsection{Homomorphic Encryption}
Elgamal point encryption based on elliptic curve cryptographic primitive is a \textit{homomorphic} encryption scheme with respect to point addition. That means, component wise addition of two cryptograms would result in a new, valid cryptogram that contains the two messages added together.
\[
\mathbf{Enc}_Y(M_1, r_1) + \mathbf{Enc}_Y(M_2, r_2) = \mathbf{Enc}_Y(M_1 + M_2, r_1 + r_2)
\]

The resulting encryption of the homomorphic addition of two cryptograms is \( e' = (R', C') \leftarrow \mathbf{AddEnc} (e_1, e_2) \) (algorithm \ref{alg: add enc}).

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{AddEnc} (e_1, e_2) \)}
    \KwData{The first cryptogram \( e_1 = (R_1, C_1) \in \mathbb{E} \)}
    \myinput{The second cryptogram \( e_2 = (R_2, C_2) \in \mathbb{E} \)}
    \( R' \gets R_1 + R_2 \)\;
    \( C' \gets C_1 + C_2 \)\;
    \( e' \gets (R', C') \)\;
    \Return{\( e' \)} \tcp*{\( e' \in \mathbb{E} \)}
\end{algorithm}
% \end{figure}

Following the procedure above, we can \textit{re-encrypt} a given encryption \( e = (R, C) \leftarrow \mathbf{Enc}_Y (M, r) \) by homomorphically adding it to an \textit{empty cryptogram} (an encryption of the neutral point $\mathcal{O}$) with randomizer \( r' \in_\mathrm{R} \mathbb{Z}_q \). The result is a new, randomly different cryptogram that contains the same message $M$. The process of generating the new cryptogram \( e' = (R', C') \leftarrow \mathbf{ReEnc}_Y (e, r') \) is described in algorithm \ref{alg: reEnc}.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{ReEnc}_Y (e, r') \)}
    \KwData{The encryption key \( Y \in E(\mathbb{F}_p) \)}
    \myinput{The initial cryptogram \( e = (R, C) \in \mathbb{E} \)}
    \myinput{The new randomizer \( r' \in \mathbb{Z}_q \)}
    \( e_2 \gets \mathbf{Enc}_Y (\mathcal{O}, r') \) \tcp*{algorithm \ref{alg: enc}}
    \( e' \gets \mathbf{AddEnc} (e, e_2) \) \tcp*{algorithm \ref{alg: add enc}}
    \Return{\( e' \)} \tcp*{\( e' \in \mathbb{E} \)}
\end{algorithm}
% \end{figure}

% \begin{equation}
%     \begin{split}
%         R' & = R + [r']G \\
%         C' & = C + [r']Y \\
%     \end{split}
% \end{equation}

% The re-encryption algorithm is actually
% \[ \mathbf{ReEnc}_Y (e, r') = \mathbf{AddEnc} (e, \mathbf{Enc}_Y (\mathcal{O}, r'))
% \]

Usually, a re-encrypted cryptogram comes with a re-encryption proof to assure that the content of the cryptogram has not been changed. The proof is a non-interactive discrete logarithm equality proof (described in section \ref{DLE}) \( PK = (\boldsymbol{K}, c, r) \leftarrow \mathbf{Prove}_{G, Y} (r') \), while the proof verification algorithm is \( b \leftarrow \mathbf{Verify}_{G, Y} (PK, R'-R, C'-C) \), where \( b \in \mathbb{B} \).

% \clearpage
\subsubsection{Elgamal Threshold Cryptosystem}
A $t$ out of $n$ threshold cryptosystem is an encryption scheme where the decryption key is split among $n$ key holders, called \textit{trustees}. Anybody can encrypt a message using the encryption key. Decryption of a message happens during a process in which at least $t$ trustees have to collaborate in a cryptographic protocol. It is recommended that \( t \geq 2/3 \cdot n \). The entire scheme is inspired from \cite{Pedersen91} which is based on mathematical principles of the threshold cryptosystem \cite{Desmedt89, Shamir79}.

The key generation algorithm outputs \( (sx_1, ..., sx_n, Y) \leftarrow \mathbf{KeyGen} (n, t) \), where $Y$ is the public encryption key and each $sx_i$ is a private share of the decryption key, one for each of the $n$ trustees. The algorithm spans over the protocol described in figure \ref{fig: threshold ceremony}, which we call \textit{the threshold ceremony}.

During the \textit{threshold ceremony}, all trustees generate a private-public key pair $(x_i, Y_i)$ and publish to the server their public keys. The public encryption key is computed by the sum of the public keys of all trustees \( Y = \sum_{i=1}^n Y_i \), while nobody being in the possession of the decryption key \( x = \sum_{i=1}^n x_i \), because all $x_i$ are secret. Instead, all trustees work together to distribute $x$ such that any $t$ trustees can find it when necessary.

Each trustee $\mathcal{T}_i$ generates a polynomial function of degree $t-1$
\[
f_i(z) = x_i + p_{i,1} \cdot z + ... + p_{i,t-1} \cdot z^{t-1}
\]
, where \( p_{i,k} \in_\mathrm{R} \mathbb{Z}_q \) with \( k \in \{ 1, ..., t-1 \} \). Next, all trustees publish to the server the curve points \( (P_{i,1}, ..., P_{i,t-1}) \), where each \( P_{i,k} \gets [p_{i,k}]G \). We call $(p_{i,k}, P_{i,k})$ a private-public polynomial coefficient pair.

When all trustees have published their public coefficients, each trustee computes a \textit{partial secret share of the decryption key} for each of the other trustees by \( s_{i,j} \gets f_i(j) \), and encrypts them with that specific trustee's public key \( e_{i,j} \gets \mathbf{EncScalar}_{Y_j} (s_{i,j}) \). Finally, all trustees publish to the server all encrypted \textit{partial secret shares of the decryption key}.

By encrypting the partial secret shares with different trustee's public key, we make sure that only that specific trustee can read his \textit{partial secret shares of the decryption key}. This procedure is a small deviation from \cite{Pedersen91}, which we introduced in order to simulate a secret communication channel between each two trustees.

Finally, each trustee $\mathcal{T}_i$ downloads his encrypted \textit{partial secret shares} $e_{j,i}$, with \( j \in \{ 1, ..., n \} \), decrypts them \( s_{j,i} \gets \mathbf{DecScalar}_{x_i} (e_{j,i}) \) and validates that they are consistent with the polynomial coefficients of the other trustees \( [s_{j,i}]G \stackrel{?}{=} Y_j + \sum_{k=1}^{t-1} [i^k] P_{j,k} \). If all \textit{partial secret shares} validate, then trustee $\mathcal{T}_i$ computes his \textit{secret share of the decryption key} by \( sx_i \gets \sum_{j=1}^n s_{j,i} \).


% \begin{center}
% \begin{tikzpicture}
% \matrix (m)[matrix of nodes, column sep = 1 cm, row sep = 0 mm, nodes = {draw = none, anchor = center, text depth = 0 pt}] {
%     Trustee$_i$ & & Server \\ [2 mm]
%     \( x_i \in_R \mathbb{Z}_q \) & & \\
%     \( Y_i = [x_i]G \) & & \\
%     & $Y_i$ & \\ [2 mm]
%     & & \scriptsize \textit{when all trustees published} $Y_i$ \\ [2 mm]
%     & & set \( t \in [ \frac{2}{3}n, ..., n] \) \\
%     & t & \\
%     \( p_{i, k} \in_R \mathbb{Z}_q \) & & \\
%     \( P_{i, k} = [p_{i, k}]G \) & & \\
%     where \( k \in \{1, ..., t-1\} \) & & \\ [2 mm]
%     set \( f_i(a) = x_i + \sum_{k=1}^{t-1} p_{i, k} \cdot a^k \) & & \\
%     & $P_{i, k}, k \in \{1, ..., t-1\}$ & \\
%     \( s_{i, j} = f_i(j) \) & & \\
%     \( e_{i, j} = (R_{i, j}, c_{i, j}) \leftarrow \mathbf{Enc}_{Y_j}(s_{i, j}) \) & & \\
%     where \( j \in \{1, ..., n\} \) & & \\
%     & \( e_{i, j}, j \in \{1, ..., n\} \) & \\ [2 mm]
%     & & \scriptsize \textit{when all} $e_{i, j}$ \textit{have been} \\
%     & & \scriptsize \textit{published,} \( i, j \in \{1, ..., n\} \) \\ [2 mm]
%     & \( e_{j, i}, j \in \{1, ..., n\} \) & \\
%     \( s_{j, i} \leftarrow \mathbf{Dec}_{x_i}(e_{j, i}) \) & & \\
%     validate \( [s_{i, j}]G = Y_j + \sum_{k=1}^{t-1} [i^k]P_{j, k} \) & & \\
%     where \( j \in \{1, ..., n\} \) & & \\ [2 mm]
%     if all valid, \( sx_i = \sum_{j=1}^{n} s_{j, i} \) & & \\
% };


% \draw[shorten <=-1.5cm, shorten >=-1.5cm] (m-1-1.south west)--(m-1-1.south east);
% \draw[shorten <=-1.5cm, shorten >=-1.5cm] (m-1-3.south west)--(m-1-3.south east);
% \draw[shorten <=-0.5cm, shorten >=-0.5cm, -latex] (m-4-2.south west)--(m-4-2.south east);
% \draw[dashed][shorten <=-6.5cm, shorten >=-1.0cm] (m-5-3.south west)--(m-5-3.south east);
% \draw[shorten <=-0.5cm, shorten >=-0.5cm, -latex] (m-7-2.south east)--(m-7-2.south west);
% \draw[shorten <=-0.5cm, shorten >=-0.5cm, -latex] (m-12-2.south west)--(m-12-2.south east);
% \draw[shorten <=-0.5cm, shorten >=-0.5cm, -latex] (m-16-2.south west)--(m-16-2.south east);
% \draw[dashed][shorten <=-6.5cm, shorten >=-1.0cm] (m-17-3.south west)--(m-17-3.south east);
% \draw[shorten <=-0.5cm, shorten >=-0.5cm, -latex] (m-19-2.south east)--(m-19-2.south west);
% \end{tikzpicture}
% \end{center}


% \begin{algorithm}[H]
% \floatname{algorithm}{Threshold ceremony}
% \renewcommand{\thealgorithm}{}
% \caption{Protocol for generating the Encryption key}
% \begin{algorithmic}[1]
% \STATE Trustee$_i$ : Each trustee generates a key pair \( (x_i, Y_i) \), where \( x_i \in_R \mathbb{Z}_q \) and \( Y_i = [x_i]G \) and publishes her public key $Y_i$.
% \STATE Server : When all trustees have published their public keys, server sets the threshold value for decryption $t$.
% \STATE Trustee$_i$ : Each trustee generates a polynomial of degree $t-1$ by generating $t-1$ coefficient pairs \( (p_{i, k}, P_{i, k}) \), where \( p_{i, k} \in_R \mathbb{Z}_q \), \( P_{i, k} = [p_{i, k}]G \) and \( k \in \{1, ..., t-1 \} \). \\
% The polynomial function is \( f_i(a) = p_{i, 0} \cdot a^0 + p_{i, 1} \cdot a^1 + ... + p_{i, t-1} \cdot a^{t-1} \), where \( p_{i, 0} = x_i \). A simpler way of writing the polynomial is
% \[
% f_i(a) = x_i + \sum_{k=1}^{t-1} p_{i, k} \cdot a^k.
% \]
% Each trustee publishes the points $P_{i, k}$, where \( k \in \{ 1, ..., t-1 \} \).
% \STATE Trustee$_i$ : Each trustee computes a partial secret for all the other trustees \( s_{i, j} = f_i(j) \), where \( j \in \{ 1, ..., n \} \).
% \STATE Trustee$_i$ : Each trustee encrypts all partial secrets for the corresponding trustee's public key, using the scalar encryption algorithm.
% \[
% e_{i, j} = (R_{i, j}, c_{i, j}) \leftarrow \mathbf{Enc}_{Y_j}(s_{i, j}, r_{i, j}).
% \]
% All partial secret cryptograms $e_{i, j}$, are published to the server. \\
% \STATE Trustee$_i$ : After all partial secret cryptograms have been published, each trustee downloads all partial secret cryptograms assigned to them \( e_{j, i} = (R_{j, i}, c_{j, i}) \) and extracts the partial secrets using the scalar decryption algorithm \( s_{j, i} \leftarrow \mathbf{Dec}_{x_i}(e_{j, i}) \).
% \STATE Trustee$_i$ : Each trustee validates that the partial secrets received are consistent with the polynomial coefficients published by the other trustees.
% \[
% [s_{i, j}]G = Y_j + \sum_{k=1}^{t-1} [i^k]P_{j, k}
% \]
% where \( j \in \{1, ..., n\} \). If all of them are valid, trustee computes her share of the decryption key by \( sx_i = \sum_{j=1}^{n} s_{j, i} \pmod q \) and lets the server know that everything is all right. Otherwise, the trustee notifies the server about the invalid partial secret that was generated by a corrupt trustee.
% \STATE Server : When all trustees have validated their share of the decryption key, the server computes the encryption key \( Y = \sum_{i=1}^{n} Y_i \).
% \STATE Anybody : At the end of the threshold ceremony, for each Trustee$_i$, with \( i \in \{ 1, ..., n \} \), the public share of the decryption key (\( sY_i = [sx_i]G \)) is publicly computable by the following:
% \[
% sY_i = \sum_{j=1}^{n} (Y_j + \sum_{k=1}^{t-1} [i^k]P_{j, k})
% \]
% \end{algorithmic}
% \end{algorithm} 

\begin{figure}[!hp]
    \centering
    \begin{tikzpicture}[framed]
        \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
            \textbf{Trustee $\mathcal{T}_i$} & & \textbf{Server} \\ [2mm]
            \scriptsize /*generate key pair*/ & & \\ [-1mm]
            \( (x_i, Y_i) \gets \mathbf{KeyGen}() \) & & \\
            & send $Y_i$ & \\
            & & \scriptsize /*\textit{when all} $Y_i$ \textit{have been} \\
            & & \scriptsize \textit{published,} \( i \in \{ 1, ..., n \} \)*/ \\ [2mm]
            & & set \( t \in [ \frac{2}{3}n, ..., n] \) \\
            & send $t$ & \\
            \scriptsize /*generate coefficient pairs*/ & & \\ [-1mm]
            for \( k = 1, 2, ..., t-1 \) do: & & \\
            -- \( (p_{i, k}, P_{i, k}) \gets \mathbf{KeyGen}() \) & & \\
            & send $P_{i,k}$ & \\
            & \scriptsize \( k \in \{ 1, ..., t-1 \} \) & \\
            set \( f_i(a) = x_i + \sum_{k=1}^{t-1} p_{i, k} \cdot a^k \) & & \\ [2mm]
            \scriptsize /*compute partial secrets for each trustee*/ & & \\ [-1mm]
            for \( j = 1, 2, ..., n \) do: & & \\
            -- \( s_{i, j} \gets f_i(j) \) & & \\
            -- \( e_{i, j} \gets \mathbf{EncScalar}_{Y_j} (s_{i, j}) \) & & \\
            & send $e_{i,j}$ & \\
            & \scriptsize \( j \in \{ 1, ..., n \} \) & \\
            & & \scriptsize /*\textit{when all} $e_{i, j}$ \textit{have been} \\
            & & \scriptsize \textit{published,} \( i, j \in \{1, ..., n\} \)*/ \\
            & send $e_{j,i}$ & \\
            & \scriptsize \( j \in \{ 1, ..., n \} \) & \\
            \scriptsize /*decrypt and validate partial secrets*/ & & \\ [-1mm]
            for \( j = 1, 2, ..., n \) do: & & \\
            -- \( s_{j, i} \gets \mathbf{DecScalar}_{x_i} (e_{j, i}) \) & & \\
            -- verify \( [s_{j,i}]G = Y_j + \sum_{k=1}^{t-1} [i^k]P_{j, k} \) & & \\ [2mm]
            \scriptsize /*compute share of the decryption key*/ & & \\ [-1mm]
            if all partial secrets validate & & \\
            -- \( b \gets true \) & & \\
            -- \( sx_i \gets \sum_{j=1}^{n} s_{j, i} \pmod q \) & & \\
            else & & \\
            -- \( b \gets false \) & & \\
            & send $b$ & \\
            & & \scriptsize /*\textit{when all} $\mathcal{T}_i$ \textit{validate}*/ \\ [3mm]
            & & \scriptsize /*compute public key*/ \\ [-1mm]
            & & \( Y \gets \sum_{i=1}^{n} Y_i \)\\
        };
        
        \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
        \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
        \draw[-latex] (m-4-2.south west)--(m-4-2.south east);
        \draw[-latex] (m-8-2.south east)--(m-8-2.south west);
        \draw[-latex] (m-12-2.south west)--(m-12-2.south east);
        \draw[-latex] (m-19-2.south west)--(m-19-2.south east);
        \draw[-latex] (m-23-2.south east)--(m-23-2.south west);
        \draw[-latex] (m-35-2.south west)--(m-35-2.south east);
        \draw[dashed, shorten <=-8.2cm, shorten >=0cm] (m-5-3.south west)--(m-5-3.south east);
        \draw[dashed, shorten <=-8.2cm, shorten >=0cm] (m-21-3.south west)--(m-21-3.south east);
        \draw[dashed, shorten <=-8.2cm, shorten >=0cm] (m-36-3.south west)--(m-36-3.south east);
    \end{tikzpicture}
    \caption{Threshold ceremony}
\end{figure}

\clearpage
At the end of the \textit{threshold ceremony}, for each trustee $\mathcal{T}_i$, with \( i \in \{ 1, ..., n \} \), the \textit{public share of the decryption key} (\( sY_i = [sx_i]G \)) is publicly computable by the following:
\[
sY_i \gets \sum_{j=1}^{n} (Y_j + \sum_{k=1}^{t-1} [i^k]P_{j, k})
\]

The encryption algorithm of the threshold cryptosystem is identical to the \textit{Point Encryption} algorithm described in section \ref{elgamal}. Note that using the threshold encryption scheme, we can only encrypt a message $M$ that is represented as a point on the elliptic curve
\[
e = (R, C) \leftarrow \mathbf{Enc}_Y(M, r).
\]

The decryption algorithm of the threshold cryptosystem is inspired from paper \cite{Desmedt89}. At least $t$ trustees are needed to collaborate in the protocol described in figure \ref{fig: threshold decryption} in order to extract the message of a cryptogram \( M \leftarrow \mathbf{Dec}_T(e) \), where \( T \subset \{ 1, ..., n \} \) is the subset of trustees that do participate in the decryption protocol, with \( |T| \geq t \) and \( e = (R, C) \) is the cryptogram to be decrypted. 
Each trustee $\mathcal{T}_i$, with \( i \in T \), computes a partial decryption \( S_i \gets [sx_i]G \) and sends it to the server, where $sx_i$ is trustee's share of the decryption key. The trustee also publishes a proof of correct decryption in form of a non-interactive discrete logarithm zero knowledge proof \( PK \leftarrow \mathbf{ProveEquality}_{G, R} (sx_i) \) (algorithm \ref{alg: Prove dle}).

When receiving a partial decryption from a trustee $\mathcal{T}_i$, the server accepts it if the proof of correct decryption validates by \( \mathbf{VerifyEquality}_{G, R} (PK, sY_i, S_i) \) (algorithm \ref{alg: Verify dle}), where $sY_i$ is trustee's \textit{public share of the decryption key}.

After it received valid, partial decryptions from all trustees $\mathcal{T}_i$, with \( i \in T \), the server aggregates all partial decryptions together to finalize the decryption and to output the message $M$. The aggregation process from \cite{Desmedt89} is described as follows:

Basically, \( M = C - [x]R \), where $x$ is the main decryption key that nobody has. A possible way of computing $[x]R$ is by calculating the \textit{Lagrange Interpolation Polynomial} where each term is a partial decryption received from a trustee $S_i$ that needs to be multiplied by the \textit{Lagrange Interpolation Polynomial coefficient} which is \( \lambda(i) = \prod_{j \in T, j \neq i} \frac{-j}{i-j} \pmod q \). Formally, \( M \gets C - \sum_{i \in T} [\lambda(i)]S_i \).

Note that the \textit{Lagrange Interpolation Polynomial} can be computed only when the number of terms is at least the degree of the polynomial, i.e \( |T| \geq t \).

% The decryption algorithm of the threshold cryptosystem involves at least $t$ trustees to collaborate in the protocol described in figure \ref{fig: threshold decryption} in order to extract the message of a cryptogram \( M \leftarrow \mathbf{Dec}_T(e) \), where \( T \subset \{ 1, ..., n \} \) is the subset of trustees containing only the ones that participate in the decryption protocol and \( e = (R, C) \) is the cryptogram to be decrypted. Each trustee $\mathcal{T}_i$ computes a partial decryption $S_i$ and sends it to the server. After it received partial decryptions from all trustees, the server aggregates all partial decryptions together to finalize the decryption and to output the message $M$. 

% Normally, when a trustee publishes a partial decryption \( S_i = [sx_i]R \), where $sx_i$ is trustee's share of the decryption key, the trustee also publishes a proof of correct decryption in form of a non-interactive discrete logarithm zero knowledge proof \( PK \leftarrow \mathbf{ProveEquality}_{G, R} (sx_i) \) (algorithm \ref{alg: Prove dle}). The server, who receives the partial decryption and the proof of correct decryption, will accept the partial decryption if the proof validates by running the algorithm \( \mathbf{VerifyEquality}_{G, R} (PK, sY_i, S_i) \) (algorithm \ref{alg: Verify dle}), where $sY_i$ is trustee's public share of the decryption key.

% \begin{algorithm}[H]
% \floatname{algorithm}{Threshold decryption}
% \renewcommand{\thealgorithm}{}
% \caption{Protocol for extracting the message of a cryptogram}
% \begin{algorithmic}[1]
% \STATE Trustee$_i$ : Each trustee with \( i \in T \) generates a partial decryption \( S_i = [sx_i]R \). Next, she generates a proof of correct decryption in form of a Elliptic Curve Discrete Logarithm Equality Non Interactive Zero Knowledge Proof \( PK_i = (K_i, c_i, r_i) \leftarrow \mathbf{Proove}_{G, R} (sx_i) \). Both the partial decryption $S_i$ and the proof $PK_i$ are published to the server.
% \STATE Server : When receiving a partial decryption from Trustee$_i$ with \( i \in T \), the server verifies that the proof is correct by the algorithm \( \mathbf{Verify}_{G, R} (PK_i, sY_i, S_i) \). If the proof is valid, the server accepts the partial decryption, otherwise, it rejects it.
% \STATE Server : When all trustees from $T$ have published valid partial decryptions, the server aggregates all of them to extract the message $M$ in the following way
% \[
% M = C - \sum_{i \in T} [\lambda(i)]S_i
% \]
% where $\lambda(i)$ is the threshold coefficient calculated dependent on who participates in the threshold decryption
% \[
% \lambda(i) = \prod_{j \in T, j \neq i} \frac{-j}{i-j} \pmod q
% \]
% \end{algorithmic}
% \end{algorithm} 

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[framed]
        \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
            \textbf{Trustee $\mathcal{T}_i$} & & \textbf{Server} \\
            [2mm]
            /*knows $sx_i$, \( e = (R, C) \)*/ & & /*knows \( e = (R, C) \), \( \{ sY_1, ..., sY_n \} \)*/ \\ [2mm]
            \scriptsize /*generate partial decryption*/ & & \\ [-1mm]
            \( S_i \gets [sx_i]R \) & & \\
            \( PK_i \gets \mathbf{ProveEquality}_{G,R} (sx_i) \) \\
            & send $S_i$, $PK_i$ & \\
            & & \scriptsize /*validate proof*/ \\ [-1mm]
            & & if \( \mathbf{VerifyEquality}_{G,R} (PK_i, sY_i, S_i) \) \\
            & & -- accept partial decryption $S_i$ \\
            & & -- include $i$ into $T$ \\ [2mm]
            & & \scriptsize /*\textit{when } \( |T| \geq t \) \\ [3mm]
            & & \scriptsize /*compute $\mathcal{T}_i$'s Lagrange Interpolation \\
            & & \scriptsize Polynomial coefficients*/ \\ [-1mm]
            & & for each \( i \in T \) do: \\
            & & -- \( \lambda(i) \gets \prod_{j \in T, j \neq i} \frac{-j}{i-j} \pmod q \) \\ [2mm]
            & & \scriptsize /*finalize decryption*/ \\ [-1mm]
            & & \( M \gets C - \sum_{i \in T} [\lambda(i)]S_i \) \\
        };
        
        \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
        \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
        \draw[-latex] (m-6-2.south west)--(m-6-2.south east);
        \draw[dashed, shorten <= -5.5cm, shorten >= -1.5cm] (m-11-3.south west)--(m-11-3.south east);
    \end{tikzpicture}
    \caption{Threshold decryption}
\end{figure}

% \clearpage
\newpage

\subsection{Schnorr Digital Signature}
The \textit{Schnorr digital signature scheme}, introduced in \cite{Schnorr90}, consists of a triple of algorithms (\textbf{KeyGen}, \textbf{Sign}, \textbf{VerifySignature}), which are based on elliptic curve cryptographic primitive.

A Schnorr key pair is a tuple \( (x, Y) \leftarrow \mathbf{KeyGen}() \) (algorithm \ref{alg: key gen}), where $x$ is the random, private signing key and $Y$ is the corresponding public signature verification key.

Only the owner of the signing key is able to generate a signature \( \sigma = (c, s) \leftarrow \mathbf{Sign}_x (m) \), on an arbitrary message \( m \in \mathbb{B}^* \). In order to generate a signature, the signer follows algorithm \ref{alg: sign}.

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{Sign}_x (m) \)}
    \KwData{The signing key \( x \in \mathbb{Z}_q \)}
    \myinput{The message to be signed \( m \in \mathbb{B}^* \)}
    \( r \in_\mathrm{R} \mathbb{Z}_q \) \\
    \( K \gets [r]G \) \\
    \( c \gets \mathcal{H}(K || m) \) \\
    \( s \gets r - c \cdot x \pmod q \) \\
    \( \sigma \gets (c, s) \) \\
    \Return{\( \sigma \)} \tcp*{\( \sigma \in \mathbb{Z}_q \times \mathbb{Z}_q \)}
\end{algorithm}
% \end{figure}

% \begin{equation}
%     \begin{split}
%         r & \in_R \mathbb{Z}_q \\
%         K & = [r]G \\
%         c & = \mathcal{H}(K || m) \\
%         s & = r - c \cdot x \pmod q \\ 
%     \end{split}
% \end{equation}

Given a signature $\sigma$ on a message $m$, anybody in the possession of the public verification key $Y$ is able to verify the validity of the signature \( b \leftarrow \mathbf{VerifySignature}_Y (\sigma, m) \), with \( b \in \mathbb{B} \) which represents $true$ or $false$. The signature verification algorithm is described in algorithm \ref{alg: verify sig}
% , by computing \( K = [s]G + [c]Y \) and checking that \( \mathcal{H}(K || m) = c \).

% \begin{figure}
\begin{algorithm}[H]
\DontPrintSemicolon
    \caption{\( \mathbf{VerifySignature}_Y (\sigma, m) \)}
    \KwData{The verification key \( Y \in E(\mathbb{F}_p) \)}
    \myinput{The signature \( \sigma = (c, s) \in \mathbb{Z}_q \times \mathbb{Z}_q \)}
    \myinput{The signed message \( m \in \mathbb{B}^* \)}
    \( K \gets [s]G + [c]Y \) \\
    \eIf{\( c = \mathcal{H}(K || m) \)}{
        \( b \gets 1 \) \tcp*{signature is valid}
        }{
        \( b \gets 0 \) \tcp*{signature is invalid}
        }
    \Return{\( b \)} \tcp*{\( b \in \mathbb{B} \)}
\end{algorithm}
% \end{figure}

\subsection{Pedersen Commitment Scheme}

\subsection{Groth's Argument of Shuffle}
