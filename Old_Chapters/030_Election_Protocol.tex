%\section{Election Protocol}

% \subsection{Involved Parties}
% In our election process multiple parties are involved. Each party represents a human with access to a computer or simply a process/software that follows a particular protocol. All these parties can be categorized into the following 6 types: 
% \begin{itemize}
%     \item \textit{Election Administrator} $\mathcal{E}$ : There exists  one or many administrators that are responsible for setting up the election event. An administrator is a person controlling a computer with access to internet.
    
%     \item \textit{Voter} $\mathcal{V}$ : There exists a list of eligible voters, each noted $\mathcal{V}_i$, with \( i \in \{ 1, ..., n_\mathrm{v} \} \), where $n_\mathrm{v}$ is the total number of voters.  A voter is a human being that is allowed to cast a valid vote in this election. A voter needs to have access to a computer that has an internet connection. Voters are the ones to generate vote cryptograms.
    
%     \item \textit{Printing Authority} $\mathcal{P}$ : The \textit{Printing Authority} is only relevant if the voter registration mode \textit{Pre-election} described in \cref{sec:voters_are_pre_determined} is used. \\
    
%     There is a set of printing authorities, each noted as $\mathcal{P}_i$, with \( i \in \{ 1, ..., n_\mathrm{p} \} \), where $n_\mathrm{p}$ is the total number of printing authorities. Each of them is responsible for generating voter credentials and distribute them privately to the voters. It is recommended that each printing authority should use a different communication channel for distributing credentials (e.g. e-mail, post, SMS). A printing authority is an institution (consisting of humans and software processes) that has to follow our protocol.
    
%     \item \textit{Trustee} $\mathcal{T}$ : There is a set of trustees, each noted as $\mathcal{T}_i$, with \( i \in \{ 1, ..., n_\mathrm{t} \} \), where $n_\mathrm{t}$ is the total number of trustees. A trustee is a human controlling a computer that has the \textit{Trustee Application} installed. Trustees are responsible for preserving the privacy and the fairness of the election during the election phase by working together to build the election encryption key while safely storing their shares of the decryption key.
    
%     \item \textit{Identity Provider} $\mathcal{I}$ : The \textit{Identity Provider} $\mathcal{I}$ is only relevant if the voter registration mode \textit{On-demand} described in \cref{sec:voters_register_during_election} is used. \\
    
%     \noindent There are a set of \textit{Identity Providers} $\mathcal{I}_i$, with $i \in \{ 1, ..., n_\mathrm{i} \}$, where $n_\mathrm{i}$ is the total number of identity providers. An Identity Provider is a third party application responsible for verifying the identity of a voter $\mathcal{V}$. The \textit{Identity Provider} $\mathcal{I}$ is responsible for verifying users on the fly during the election phase. It must be assumed that the \textit{Identity Provider} $\mathcal{I}$ follows the OIDC protocol.
    
%     \item \textit{Voter Authorization Service} $\mathcal{A}$ : The \textit{Voter Authorization Service} $\mathcal{A}$ is only relevant if the voter registration mode \textit{On-demand} described in \cref{sec:voters_register_during_election} is used. \\
    
%     \noindent The \textit{Voter Authorization Service} $\mathcal{A}$ is a service that is responsible for authorizing a \textit{Voter} $\mathcal{V}$ after being verified by the identify provider. The \textit{Voter Authorization Service} $\mathcal{A}$ is together with the set of \textit{Identity Providers} $\mathcal{I}$ responsible for preserving the eligibility of the election by preventing any non-eligible voters from voting.
    
%     \item \textit{Mix Node} $\mathcal{M}$ : There exists a mixnet represented by a set of mix nodes, each noted as $\mathcal{M}_i$, with \( i \in \{ 1, ..., n_\mathrm{m} \} \), where $n_\mathrm{m}$ is the total number of mix nodes. A mix node is a software process that runs on a separate server with enough computation capability. The mixnet is responsible for preserving the anonymity of the election by shuffling the entire list of vote cryptograms in an indistinguishable way.
    
%     \item \textit{Digital Ballot Box} $\mathcal{D}$ : Is the communication central unit as all other parties push/pull data to/from it. It is a piece of software, accessible over internet by any other actor involved in the election process. The \textit{Digital Ballot Box} $\mathcal{D}$ has a bulletin board that contains all the public information about an election which consists of three parts: 
%     \begin{enumerate}
%         \item \textit{election configuration}, which has to be set up during the pre-election phase. All data included here is described at section \ref{pre-election phase}.
%         \item \textit{list of vote cryptograms}, which is being populated during the election phase. The list is implemented with the following properties: no elements of the list are ever removed or modified; each new element is appended at the end of the list.
%         \item \textit{mixing and decryption files}, which are collected during the post-election phase. These files contribute in the process of computing the result of the election.
%     \end{enumerate}
% \end{itemize}

% \subsection{Voter registration modes}
% AVX supports two mutually exclusive voter registration modes: \textit{Pre-election} and \textit{On-demand}. Both names referring to when voters are registered in the election in their respective mode. The mentioned actors ($\mathcal{P}$, $\mathcal{I}$, and $\mathcal{A}$) in the subsections below are exclusive to the mode mentioned in.


% \subsubsection{Pre-election}
% For this configuration there is a set of \textit{Printing Authorities} $\mathcal{P}$ which are responsible for generating the voter credentials and distributing them for a list of pre-approved eligible voters \( \boldsymbol{\mathcal{V}} = (\mathcal{V}_1, ..., \mathcal{V}_{n_\mathrm{v}}) \) who can be authorized to vote by providing their credentials.


% \subsubsection{On-demand}
% In this configuration there is a list of eligible voters \( \boldsymbol{\mathcal{V}} = (\mathcal{V}_1, ..., \mathcal{V}_{n_\mathrm{v}}) \) but when the system enters the election phase these potential voters need to confirm their identity $\mathcal{V}_i$ through the \textit{Identity Providers} $\boldsymbol{\mathcal{I}} = (\mathcal{I}_1, ..., \mathcal{I}_{n_\mathrm{i}})$, where $n_\mathrm{i}$ is the total number of identity providers. With successful confirmations, the identity is checked by the \textit{Voter Authorization Service} $\mathcal{A}$ to see if it is part of the list of pre-approved eligible voters (i.e. $\mathcal{V}_i \in \boldsymbol{\mathcal{V}}$). If eligible, then the \textit{Voter Authorization Service} $\mathcal{A}$ returns an authorization token that will give the voter access to vote.

% \subsection{Append-only Bulletin Board}

% All events that happen during an election are published by the \textit{Digital Ballot Box} $\mathcal{D}$ as items on a publicly available bulletin board. Each item from the board is owned (or written) by a relevant actor. Each item posted on the bulletin board describes a specific event and it is uniquely identifiable by its \textit{hash value}. The \textit{hash value} of the last item on the board represents the \textit{board hash value} at that specific point in time. All events are stored as an \textit{append only list}, that means, no event can be removed or replaced and each new event is appended at the end of the list. The structure of the bulletin board has been inspired from \cite{Heather09}.

% The way we deviate from \cite{Heather09} is that, to append a new item on the board, the writer needs to include as part of the new item a reference to any existing item from the board (i.e. include the \textit{hash value} of that item), instead of referencing exactly the previous item. We call this reference, the \textit{parent item}. Finally, the \textit{hash value} of the new item is computed by the \textit{Digital Ballot Box} $\mathcal{D}$ by hashing the content of the item (including the reference to the \textit{parent item}) concatenated with the current \textit{board hash value} and a registration timestamp. $\mathcal{D}$ signs the \textit{hash value} of the new item and delivers it to the writer as proof of acceptance of the new item on the board. Note that the \textit{Digital Ballot Box} ensures that the new item is linked directly to the previous item on the board.

% As a result of this modification, each item from the bulletin board references 2 other items:
% \begin{enumerate}
%     \item an existing item that the writer chooses as the \textit{parent item} and
%     \item the previous item of the board
% \end{enumerate}

% This modification to the bulletin board structure implies that the \textit{history} property described in \cite{Heather09} is protected in this case by the \textit{Digital Ballot Box}. Furthermore, we introduce a new property to the bulletin board called \textit{ancestry} which is defined by items being related to each other in a meaningful way. As a result, when traversed on the \textit{ancestry} line, the structure of the bulletin board looks like a tree, while, when traversed on the \textit{history} line, the structure looks linear. 

% In addition, we introduce a new concept to the bulletin board structure, that we call a \emph{hidden verification track}, that is used for performing the \textit{ballot checking process} described in section \ref{encryption challenge}. It is called:
% \begin{itemize}
%     \item \emph{track} because it spawns an extra \textit{history} of events that is injected under a specific item from the main \textit{history},
%     \item \textit{verification} because this track is used just for the purpose of the \textit{ballot checking process}
%     \item \emph{hidden} because this track is not publicly available as part of the bulletin board, instead, it is available on request based on the \textit{hash value} of a specific event.
% \end{itemize}

% As a consequence of these modifications, any $i^\mathrm{th}$ item from the bulletin board consists of the following tuple $(m_i, \mathcal{W}, \sigma_i, p_i, h_{i-1}, t_i, h_i)$, where $m_i$ is the description of the event, $\mathcal{W}$ is a reference to a generic writer of the item, $\sigma_i$ is the writer's signature, $p_i$ is the \textit{hash value} of the parent item with $p_i \in (h_1, ..., h_{i-1})$, $h_{i-1}$ is the \textit{hash value} of the previous item in the \textit{history}, $t_i$ is the registration timestamp and $h_i$ is the item's \textit{hash value}.

% The different kinds of items and the events they support are described in section \ref{bulletin_board_event_types}. The rules about how items can reference a parent item are also described in this section.

% In order to write a new item on the bulletin board, a writer needs to follow the protocol described in section \ref{writing_on_the_board}. The following actors are allowed to write on the bulletin board:
% \begin{itemize}
%     \item \textit{Election Administrator} $\mathcal{E}$ is the actor that writes all the configuration events of an election.
%     \item \textit{Voters} $\mathcal{V}_i$, with $i \in (1, ..., n_\mathrm{v})$, are the actors that write all the vote related events of an election.
%     \item \textit{Digital Ballot Box} $\mathcal{D}$ is the actor that ultimately accepts all the events that are published on the bulletin board. In addition, $\mathcal{D}$ also writes on the board all the auxiliary events that support the voting process.
%     \item \textit{External Verifier} $\mathcal{X}$ is the actor that writes events related to ballot checking process. These events are not part of the public track of the bulletin board.
% \end{itemize}



% % \clearpage
% % \begin{figure}[h]
% %     \centering
% %     \begin{tikzpicture}[framed]
% %         \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
% %             \textbf{Voter $\mathcal{V}_i$} & & \textbf{Digital Ballot Box} $\mathcal{D}$ \\
% %             /*knows $x_j, PK_i$*/ & & /*knows $x_\mathrm{sign}, \epsilon,$*/\\
% %             /* $e_i = (R_i, C_i)$ */ & & /*$e_{0,i} = (R_{0,i}, C_{0,i})$*/\\ [2mm]
% %             & initialize process & \\ [1mm]
% %             & & \scriptsize /*get time stamp of acknowledged hash*/ \\ [-1mm]
% %             & & \( t_{\mathrm{a},i} \gets \) current date time \\
% %             & & \( h_{\mathrm{a},i} \gets \) current board hash value \\
% %             & send $h_{\mathrm{a},i}$, $t_{\mathrm{a},i}$ & \\ [1mm]
% %             \( s \gets \mathrm{vID} || \mathrm{eID} || e_i || t_{\mathrm{a},i} || h_{\mathrm{a},i} \) & & \\
% %             \( h_{\mathrm{v},i} \gets \mathcal{H}(s) \) & & \\
% %             \( \sigma_i \gets \mathbf{Sign}_{x_j}(h_{\mathrm{v},i}) \) & & \\
% %             & send $\sigma_i, e_i, h_{\mathrm{v},i}, PK_i$ & \\ [1mm]
% %             & & \scriptsize /*get registration time stamp*/ \\ [-1mm]
% %             & & \( t_{\mathrm{r},i} \gets \) current date time \\ [2mm]
% %             & & \scriptsize /*verify vote submission*/ \\ [-1mm]
% %             & & \( s \gets \mathrm{vID} || \mathrm{eID} || e_i || t_{\mathrm{a},i} || h_{\mathrm{a},i} \) \\
% %             & & if \( h_{\mathrm{v},i} \stackrel{?}{=} \mathcal{H}(s) \) and \( t_{\mathrm{r},i} < t_{\mathrm{a},i} + \epsilon \) \\
% %             & & and \( \mathbf{VerifySignature}_{Y_j} (\sigma_i, h_{\mathrm{v},i}) \) \\
% %             & & and \( \mathbf{Verify}_{G} (PK_i, R_i - R_{0,i}) \) \\
% %             % & & and \( t_{\mathrm{r},i} < t_{\mathrm{g},i} + \epsilon \) \\
% %             & & -- \( h_{\mathrm{b},i} \gets \mathcal{H}(h_{\mathrm{v},i} || h_{\mathrm{b},i-1} || t_{\mathrm{r},i}) \) \\
% %             & & -- \( \rho_i \gets \mathbf{Sign}_{x_\mathrm{sign}}(\sigma_i || h_{\mathrm{b},i}) \) \\
% %             & send $\rho_i, t_{\mathrm{r},i}$ & \\
% %             & $h_{\mathrm{b},i}, h_{\mathrm{b},i-1}$ & \\
% %             \scriptsize /*verify receipt*/ & & \\ [-1mm]
% %             \( h_{\mathrm{b},i} \stackrel{?}{=} \mathcal{H}(h_{\mathrm{v},i} || h_{\mathrm{b},i-1} || t_{\mathrm{r},i}) \) & & \\
% %             \( r \gets \sigma_i || h_{\mathrm{b},i} \) & & \\
% %             \( \mathbf{VerifySignature}_{Y_\mathrm{sign}} (\rho_i, r) \) & & \\
% %         };
        
% %         \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
% %         \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
% %         \draw[-latex] (m-4-2.south west)--(m-4-2.south east);
% %         \draw[-latex] (m-8-2.south east)--(m-8-2.south west);
% %         \draw[-latex] (m-12-2.south west)--(m-12-2.south east);
% %         \draw[-latex] (m-22-2.south east)--(m-22-2.south west);
% %     \end{tikzpicture}
% %     \caption{Protocol for submitting vote cryptograms} 
% % \end{figure}

% \subsubsection{Writing on the Bulletin Board}

% This section describes the protocol that any writer needs to follow in order to write an event on the bulletin board. The election protocol allows a predefined set of actors ($\mathcal{E}$, $\mathcal{V}_i$, $\mathcal{D}$ or $\mathcal{X}$) to write events on the bulletin board, but for the sake of generalization, figure \ref{fig:writing_on_the_board_protocol} presents the interaction between a generic writer $\mathcal{W}$ and the \textit{Digital Ballot Box} $\mathcal{D}$ necessary for publishing a new event on the bulletin board.

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}[framed]
%         \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
%             \textbf{Writer $\mathcal{W}$} & & \textbf{Digital Ballot Box} $\mathcal{D}$ \\
%             /*knows $x_\mathcal{W}, Y_\mathcal{D}, m_i, p_i$*/ & & /*knows $x_\mathcal{D}, Y_\mathcal{W}$*/\\ [2mm]
%             \( \sigma_i \gets \mathbf{Sign}_{x_\mathcal{W}}(m_i || p_i) \) & & \\
%             & send $\sigma_i, m_i, p_i$ & \\ [1mm]
%             & & \( t_i \gets \) current date time \\ [2mm]
%             & & \scriptsize /*verify the referenced item*/ \\ [-1mm]
%             & & if \( p_i \in (h_1, ..., h_{i-1})\) and \\
%             & & \( \mathbf{VerifySignature}_{Y_\mathcal{W}} (\sigma_i, m_i || p_i) \) \\
%             & & -- \( h_i \gets \mathcal{H}(m_i || p_i || h_{i-1} || t_i) \) \\
%             & & -- \( \rho_i \gets \mathbf{Sign}_{x_\mathcal{D}}(\sigma_i || h_i) \) \\
%              & & \scriptsize /*store in db as the $i^\mathrm{th}$ item the tuple*/ \\ [-1mm]
%             & & \( (m_i, \mathcal{W}, \sigma_i, t_i, p_i, h_i) \) \\
%             & send $\rho_i, t_i$ & \\
%             & $h_i, h_{i-1}$ & \\
            
%             \scriptsize /*verify receipt*/ & & \\ [-1mm]
%             \( h_i \stackrel{?}{=} \mathcal{H}(m_i || p_i || h_{i-1} || t_i) \) & & \\
%             \( \mathbf{VerifySignature}_{Y_\mathcal{D}} (\rho_i, \sigma_i || h_i) \) & & \\  
%         };
        
%         \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
%         \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
%         \draw[-latex] (m-4-2.south west)--(m-4-2.south east);
%         \draw[-latex] (m-13-2.south east)--(m-13-2.south west);
%     \end{tikzpicture}
%     \caption{Protocol for writing the $i$\textsuperscript{th} item on the bulletin board} 
% \end{figure}

% The publicly available information consists of: the public key of the writer $Y_\mathcal{W}$, the public key of the \textit{Digital Ballot Box} $Y_\mathcal{D}$ and all the already existing items on the bulletin board with their respective hash values $\boldsymbol{h} = (h_1, ... h_{i-1})$. The writer alone is in possession of his private key $x_\mathcal{W}$, while the \textit{Digital Ballot Box} is in possession of its private key $x_\mathcal{D}$.

% The protocol starts by the writer picking the message $m_i$ to be appended on the bulletin board as the $i^\mathrm{th}$ item. The message is a text blob describing a specific event. The structure of the message has to follow the rules described in section \ref{bulletin_board_event_types} depending on the type of item chosen. Then, the writer chooses a pre-existing item on the bulletin board as the parent of the new item. The parent item is referenced by its hash value $p_i \in \boldsymbol{h}$. The choice of parent item is done according to the rules described in section \ref{bulletin_board_event_types} depending on the type of item chosen.

% The writer signs with his private key $x_\mathcal{W}$ the content of the new item concatenated with its parent hash value $m_i || p_i$. The resulting signature $\sigma_i$ is sent together with the content $m_i$ and the parent hash value $p_i$ to the \textit{Digital Ballot Box} as a request to append the new item on the board.

% \textit{Digital Ballot Box} verifies whether $p_i$ and $m_i$ are chosen according to the rules specified in section \ref{bulletin_board_event_types} and whether the request has a valid signature. If all validations succeed, \textit{Digital Ballot Box} generates the hash value of the new item $h_i$ by hashing a concatenation of the content of the new item $m_i$, its parent hash value $p_i$, the current board hash value $h_{i-1}$ and the registration timestamp $t_i$. It, then, stores the new item on the bulletin board as the tuple $(m_i, \mathcal{W}, \sigma_i, t_i, p_i, h_i)$, where $\mathcal{W}$ is a reference to the writer.

% The \textit{Digital Ballot Box} signs with its private key $x_\mathcal{D}$ the concatenation of the writer's signature $\sigma_i$ and the hash value of the new item $h_i$. The resulting signature $\rho_i$ is sent together with the registration timestamp $t_i$, the new board hash value $h_i$ and the exactly previous board hash value $h_{i-1}$ to the writer as proof that the item has been appended on the board.

% Finally, the writer verifies whether the hash value of the new item is computed correctly and whether the response has a valid signature.

% Note that, when the protocol is performed by a specific writer, for example, the \textit{Voter} $\mathcal{V}_i$, the writer's key pair $(x_\mathcal{W}, Y_\mathcal{W})$ will be replaced by the \textit{Voter's} key pair $(x_{\mathcal{V}_i}, Y_{\mathcal{V}_i})$.


% % \clearpage

% \color{red}
% no

% The process of having a vote submitted to the bulletin board starts by the \textit{Voter} $\mathcal{V}_i$ asking for the latest hash value of the board. The \textit{Digital Ballot Box} $\mathcal{D}$ returns the current hash value of the board $h_{\mathrm{a},i}$ and the current time stamp $t_{\mathrm{a},i}$, which will be used as parameters in the generation of the vote submission. The entire process can be seen in figure \ref{fig:vote_submission_protocol}.

% no

% Each time a new submission of a vote cryptogram \( (e_i, h_{\mathrm{v},i}, \sigma_i, PK_i) \) is received, the \textit{Digital Ballot Box} $\mathcal{D}$ validates the following:
% \begin{itemize}
%     \item the vote submission is not too old, i.e. \( t_{\mathrm{a},i} < t_{\mathrm{r},i} < t_{\mathrm{a},i} + \epsilon \), where $t_{\mathrm{r},i}$ is the registration timestamp and $\epsilon$ is the \textit{latency parameter}, which represents the maximum time the vote submission process can take,
%     \item the authenticity of the vote submission, i.e. $\sigma_i$ is a valid, well-formatted signature,
%     \item the correctness of the vote cryptogram, i.e. validate that $e_i$ is constructed based on the empty cryptogram $e_{0,i}$ by checking the proof of correct encryption $PK_i$.
% \end{itemize}

% no

% If all validations succeed, the vote submission is registered (as the $i^{th}$ item on the list) and a new board hash value is calculated \( h_{\mathrm{b}, i} = \mathcal{H} (h_{\mathrm{v},i} || h_{\mathrm{b}, i-1} || t_{\mathrm{r},i}) \), where $e_i$ is the vote cryptogram, $h_{\mathrm{v},i}$ is the vote's content hash, $\sigma_i$ is the \textit{Voter} $\mathcal{V}_i$'s signature on the vote submission and $t_{\mathrm{r},i}$ is the registration time stamp.

% no

% It is visible that the board hash value is calculated based on the previous board hash value in a \textit{blockchain} like manner where each vote received is a block in the chain. The first element of the bulletin board will compute its board hash value by using the previous board hash the value \( h_{\mathrm{b},0} = 0 \) (\textit{genesis hash}).

% \begin{itemize}
%     \item If the \textit{Voter} $\mathcal{V}_i$ chooses to challenge the encryption, the browser will print on the screen all information about the vote cryptogram that is necessary to revert the encryption process (i.e. the vote cryptogram $e$, the encryption key $Y_\mathrm{enc}$ and the randomizer $r$). The \textit{Voter} $\mathcal{V}_i$ must use a second, \textbf{trusted} device to perform the decryption process, in order to output the plain text $m$. If the vote $m$ corresponds to the selected candidate, the \textit{Voter} $\mathcal{V}_i$ gains confidence that his browser behaved correctly, otherwise, there is a clear evidence of an attack to the \textit{Voter} $\mathcal{V}_i$'s machine.
    
%     The \textit{Voter} $\mathcal{V}_i$ has to recast/regenerate his vote (return to previous bullet point 2) and he can repeat this process as many times as needed until he gains enough trust in the voting application.
    
%     \item The browser asks the \textit{Digital Ballot Box} $\mathcal{D}$ for the latest hash value of the board $h_\mathrm{a}$, which we call \textit{the acknowledged hash}. The browser computes the vote's content hash $h_\mathrm{v} = \mathcal{H}(s)$, where $s$ is a message containing the following information: the voter id, the election id, the vote cryptogram $e$, the acknowledged hash $h_\mathrm{a}$ and the acknowledged time stamp. 
    
%     \item The browser certifies the authenticity of the vote cryptogram by generating a response (signature) of the \textit{Voter} $\mathcal{V}_i$ on the vote's content hash as a \textit{Schnorr signature} \( \sigma \leftarrow \mathbf{Sign}_{x_i} (h_\mathrm{v}) \) (algorithm \ref{alg: sign}). The browser submits to the \textit{Digital Ballot Box} $\mathcal{D}$ the following: the vote cryptogram $e$, the proof of correct encryption $PK$, the vote content hash $h_\mathrm{v}$ and the signature $\sigma$.
    
%     % \item The browser certifies the authenticity of the vote cryptogram by generating a signature of the voter $\mathcal{V}_j$ on a message $s$ containing the following information: voter id, election id, generation time stamp and the vote cryptogram $e$. The resulting \textit{Schnorr signature} is \( \sigma \leftarrow \mathbf{Sign}_{x_j} (s) \) (algorithm \ref{alg: sign}). The browser submits to the bulletin board the following: the vote cryptogram $e$, the proof of correct encryption $PK$, the generation time stamp and the signature $\sigma$.
    
%     \item The \textit{Digital Ballot Box} $\mathcal{D}$ receives this information and accepts the new vote cryptogram if all the following are valid: the proof of correct encryption, the vote content hash, the voter's signature and the acknowledged time stamp is not too old (described in section \ref{bulletin board}).
    
%     % \item The bulletin board $\mathcal{D}$ receives this information and accepts the new vote cryptogram if both the proof of correct encryption and the voter's signature are valid. The voter's signature is verified by reconstructing the message of the signature $s$ (voter id, election id, generation time stamp and the vote cryptogram $e$) and running the \textit{Schnorr signature} verification algorithm \( \mathbf{Verify}_{Y_j} (\sigma, s) \) (algorithm \ref{alg: verify sig}).
    
%     \item If the encrypted vote is accepted, the \textit{Digital Ballot Box} $\mathcal{D}$ appends it to the bulletin board at the end of the list of vote cryptograms. Next, the \textit{Digital Ballot Box} $\mathcal{D}$ calculates the new hash value of the list (see section \ref{bulletin board}) $h_\mathrm{b} = \mathcal{H}(b)$, where $b$ is a message that contains the following information: the vote content hash $h_\mathrm{v}$, the previous hash value of the board $h_{\mathrm{b}-1}$ and the registration time stamp $t_{\mathrm{r}}$. Afterwards, the \textit{Digital Ballot Box} $\mathcal{D}$ sends back to the \textit{Voter} $\mathcal{V}_i$ a confirmation receipt $\rho$ in form of a \textit{Schnorr signature} on the following message $r$: \textit{Voter} $\mathcal{V}_i$'s signature $\sigma$ and the new hash value of the board $h_\mathrm{b}$. The confirmation receipt is computed \( \rho \leftarrow \mathbf{Sign}_{x_\mathrm{sign}} (r) \) (algorithm \ref{alg: sign}).
% \end{itemize}

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}[framed]
%         \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
%             \textbf{Voter $\mathcal{V}_i$} & & \textbf{Digital Ballot Box} $\mathcal{D}$ \\ [2mm]
%             /*knows $x_j$*/ & & /*knows \( \boldsymbol{Y} = (Y_1, ..., Y_{n_\mathrm{v}}) \)*/ \\ [2mm]
%             \( PK \gets \mathbf{Prove}_G (x_j) \) & & \\
%             & send $j$, $PK$ & \\
%             & & \scriptsize /*validate proof*/ \\ [-1mm]
%             & & if \( \mathbf{Verify}_G (PK, Y_j) \) \\
%             & & -- successful authentication \\
%         };
        
%         \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
%         \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
%         \draw[-latex] (m-4-2.south west)--(m-4-2.south east);
%     \end{tikzpicture}
%     \caption{Protocol for voter authentication}
% \end{figure}
% \color{black}
    
% \subsubsection{Bulletin board event types}
% The bulletin board has been designed as a self-documented event log. In order to support that, it needs to contain many kinds of items that are documenting different events throughout the election, such as events related to election configuration, voting or events related to performing the ballot checking process (described in \ref{encryption challenge}).

% // TODO

% Election configuration belongs also to the bulletin board. An \textit{Election Administrator} $\mathcal{E}$ is able to generate a special kind of bulletin board item, called \textit{ a system event}, that describes the election context. For example, such system events can define the following:
% \begin{itemize}
%     \item \textit{election configuration} that includes: the election signature verification key $Y_\mathrm{sign}$, the encryption key $Y_\mathrm{enc}$, the election start and closing dates,
%     \item \textit{ballot configuration} that includes: the question of the election and all candidate names \( (m1, ..., m_{n_\mathrm{c}}) \), where $n_\mathrm{c}$ is the total number of candidates,
%     \item \textit{voters configuration} that includes: the list of eligible voters, each represented by an id and a signature verification key $Y_i$, where \( i \in \{1, ..., n_\mathrm{v} \} \) and $n_\mathrm{v}$ is the total number of voters,
%     \item \textit{threshold configuration} that includes: the threshold limit $t$ and the list of all trustees, each represented by an id, a public key $Y_i$ and the list of public polynomial coefficients $P_{i,k}$, where \( i \in \{ 1, ... n_\mathrm{t} \} \), \( k \in \{ 1, ..., t-1 \} \) and $n_\mathrm{t}$ is the total number of trustees (recall from section \ref{threshold ceremony}). 
% \end{itemize}

% The structure of a system event follows the structure of a vote submission. A system event has a registration time $t_{\mathrm{r,}i}$, a content hash $h_{\mathrm{c,}i}$ and a signature \( \sigma_i \leftarrow \mathbf{Sign}_{x_\mathrm{sign}} (h_{\mathrm{c,}i}) \) (algorithm \ref{alg: sign}), which certifies that the event has been generated by the \textit{Digital Ballot Box} $\mathcal{D}$. Recall from section \ref{pre-election phase} that $x_\mathrm{sign}$ is the \textit{Digital Ballot Box} $\mathcal{D}$'s signing key. When the event has been appended on the bulletin board, a new board hash value is computed, by following the same strategy: \( h_{\mathrm{b}, i} = \mathcal{H} (h_{\mathrm{c},i} || h_{\mathrm{b}, i-1} || t_{\mathrm{r},i}) \), where $h_{\mathrm{b}, i-1}$ is the previous board hash value.

% % \clearpage
% % The election process starts by having the election configuration locked down on the bulletin board in form of system events that describe voters, ballots, candidates, trustees and all other election details. If any change happens to the election configuration during the election process, a system event that describes the change is generated and appended on the board. That change will be effective in the election process from that moment on.

% The election process starts by having the election context locked down on the bulletin board in form of system events: an \textit{election configuration}, a \textit{ballot configuration}, a \textit{voters configuration} and a \textit{threshold configuration} events. If any change happens to the election context during the election process, a system event that describes the change is generated and appended on the board. That change will be effective in the election process from that moment on.

% \subsection{Pre-election Phase}
% During the \textit{pre-election phase} the \textit{election administrator} $\mathcal{E}$ has to gather all the information needed to set up an election. That includes:
% \begin{itemize}
%     \item The election start date and end date.
%     \item The election question and election type.
%     \item The possible answers (vote options) \( \boldsymbol{m} = (m_1, ..., m_{n_\mathrm{c}}) \), where $n_\mathrm{c}$ is the number of vote options, each representing a candidate name.
%     \item The list of eligible voters \( \boldsymbol{\mathcal{V}} = (\mathcal{V}_1, ..., \mathcal{V}_{n_\mathrm{v}}) \). Depending on the voter registration mode the voter is defined differently:
%     \\ \noindent \textit{(Pre-election)} Each voter is defined by contact information for each of the communication channels that is used in the voter credential distribution process (\cref{credential distribution}), e.g. an e-mail address, a postal address or a phone number.
%      \\ \noindent \textit{(On-demand)} Each voter is defined by unique identities that are used by all \textit{Identity Providers} $\boldsymbol{\mathcal{I}}$. The \textit{Voter Authorization Service} $\mathcal{A}$ links a voter to an identity token and an authorization token.
%     \item The lists of trustees \( \boldsymbol{\mathcal{T}} = (\mathcal{T}_1, ..., \mathcal{T}_{n_\mathrm{t}}) \) and mix nodes \( \boldsymbol{\mathcal{M}} = (\mathcal{M}_1, ..., \mathcal{M}_{n_\mathrm{m}}) \).
%     \item Generating its own key pair \( (x_\mathcal{E}, Y_\mathcal{E}) \leftarrow \mathbf{KeyGen}() \) where $x_\mathcal{E}$ is the signing key and will be kept secret throughout the election period, and $Y_\mathcal{E}$ is the public signature verification key.
% \end{itemize}

% \noindent Additionally, depending on the type of voter registration mode chosen, the \textit{Election Administrator} $\mathcal{E}$ also has to gather either:
% \paragraph{Pre-election}
% \begin{itemize}
%     \item The list of printing authorities \( \boldsymbol{\mathcal{P}} = (\mathcal{P}_1, ..., \mathcal{P}_{n_\mathrm{p}}) \) used for distributing voter credentials. Each printing authority is specified to use a particular communication channel for distributing voter credentials, e.g. e-mail, post or SMS. 
%     \item All printing authorities participate in the \textit{voter credential distribution process} to distribute voter credentials. Public signature verification keys are computed for all voters $(Y_1, ..., Y_{n_\mathrm{v}})$ and shared with the \textit{election administrator}. The process is described in section \ref{credential distribution}.
% \end{itemize}
% \paragraph{On-demand}
% \begin{itemize}
%     \item The \textit{Voter Authorization Service} $\mathcal{A}$ will generate its signing key pair \( (x_\mathcal{A}, Y_\mathcal{A}) \leftarrow \mathbf{KeyGen}() \) (algorithm \ref{alg: key gen}), where $x_\mathcal{A}$ is the signing key which will be kept secret throughout the election period, and $Y_\mathcal{A}$ is the public signature verification key which will be shared. The \textit{Voter Authorization Service} $\mathcal{A}$ is also loaded with the list of eligible voters $\boldsymbol{\mathcal{V}}$.
%   % \item The public key of \textit{Bulletin Board} $\mathcal{D}$
%   \item Connection is established with the \textit{Identity providers} $\boldsymbol{\mathcal{I}}$ and they exchange their public keys (\( Y_1, ..., Y_{n_\mathrm{i}} \)) with the \textit{election administrator}. Each \textit{Identity Provider} \( \mathcal{I}_i \in \boldsymbol{\mathcal{I}} \) is supposed to use a unique kind of identity as a means of voter identification (e.g. email, phone number, social security number). 
% \end{itemize}

% Next, all trustees participate in the \textit{threshold ceremony}, described in section \ref{threshold ceremony} in order to generate the election encryption key $Y_\mathrm{enc}$ and each trustee's share of the decryption key $sx_i$. Formally, \( (sx_1, ..., sx_{n_\mathrm{t}}, Y_\mathrm{enc}) \leftarrow \mathbf{KeyGen}(n_\mathrm{t}, t) \) (figure \ref{fig: threshold ceremony}), where $t$ is the threshold limit for decryption.

% Next, the \textit{Digital Ballot Box} $\mathcal{D}$ will generate its signing key pair \( (x_\mathcal{D}, Y_\mathcal{D}) \leftarrow \mathbf{KeyGen}() \) (algorithm \ref{alg: key gen}), where $x_\mathcal{D}$ is the signing key and will be kept secret throughout the election period, and $Y_\mathcal{D}$ is the public signature verification key of the \textit{Digital Ballot Box} $\mathcal{D}$.

% Then, the \textit{Digital Ballot Box} $\mathcal{D}$ will generate the genesis item on the bulletin board which is the initial item on the board that contains metadata of the bulletin board and does not reference any previous items. Then the EA generates the election config item which contains .

% Next, the system maps all vote options $\boldsymbol{m}$ to unique points on the elliptic curve \( \boldsymbol{M} = (M_1, ..., M_{n_\mathrm{c}}) \in E(\mathbb{F}_p)^{n_\mathrm{c}} \) with each \( M_i = \mathbf{String2Point} (m_i) \) (algorithm \ref{alg: string to point}). All vote options have to be represented in $E(\mathbb{F}_p)$ so they can be used in cryptographic procedures. The mapping algorithm is described at section \ref{vote mapping}.

% \subsubsection{Voter Credential Distribution Process}
% This process is only applicable if the vote registration mode is \textbf{Pre-election}, as described in \cref{sec:voters_are_pre_determined}. \\

% \noindent Each \textit{Printing Authority} \( \mathcal{P}_j \in \boldsymbol{\mathcal{P}}\), receives a list of voters consisting of contact details for each voter \( \boldsymbol{a} = (a_1, ..., a_{n_\mathrm{v}}) \) in form of e-mail addresses or postal addresses or phone numbers, depending on the printing authority's communication channel. The printing authority generates a random key pair for each of them \( (x_{i, j}, Y_{i, j}) \leftarrow \mathbf{KeyGen}() \) (algorithm \ref{alg: key gen}), with \( j \in \{ 1, ..., n_\mathrm{p} \} \) and \( i \in \{ 1, ..., n_\mathrm{v} \} \). The Printing Authority distributes the secret key $x_{i, j}$ to that specific voter $\mathcal{V}_i$ (using voter's contact detail $a_i$) and appends the corresponding public key $Y_{i, j}$ in the list of voters next to the specific voter $\mathcal{V}_i$.

% All printing authorities return to the \textit{election administrator} the lists with voters contact details and public keys $(a_i, Y_{i, j})$. The \textit{election administrator} combines all public keys received from all printing authorities for each voter to form voter's public signature verification key \( Y_i = \sum_{j=1}^{n_\mathrm{p}} Y_{i, j} \).

% For authenticating to the voting system, the voter \( \mathcal{V}_i \in \boldsymbol{\mathcal{V}} \) has to input in the browser all secret keys \( (x_{i, 1}, ..., x_{i, n_\mathrm{p}}) \) received via different channels from all printing authorities. The browser will combine all of them to form the voter's signing key \( x_i = \sum_{j=1}^{n_\mathrm{p}} x_{i, j} \pmod q \).


% \subsubsection{Mapping Vote Options on the Elliptic Curve}
% An expressed vote (a vote in plain text) must be able to be converted, deterministically, into an elliptic curve point in order to be used in our cryptographic protocols. Additionally, a point from the elliptic curve must be able to be turned back to a plain text vote, if the point has been constructed from a plain text. Consequently, only a finite number of points from $E(\mathbb{F}_p)$ can be mapped to a plain text that can be interpreted as valid votes. All the other points will be regarded as invalid votes. 

% The mapping procedure from a plain text $m$ to an elliptic curve point $M$ is called \( M \leftarrow \mathbf{String2Point}(m) \) and is described in the algorithm \ref{alg: string to point}. Recovering the text of the vote $m$ from an elliptic curve point $M$ can be done by calling \( m \leftarrow \mathbf{Point2String}(M) \) (algorithm \ref{alg: point to string}).
% % \begin{figure}
% % \begin{algorithm}[!h]
% % \DontPrintSemicolon
% %     \caption{\( \mathbf{Point2String} (M) \)}
% %     \KwData{The point \( M = (x, y) \in E(\mathbb{F}_p) = \mathbb{Z}_q \times \mathbb{Z}_q \)}
% %     \( \boldsymbol{b} = (b_1, ..., b_{32}) \gets \mathbf{ByteRepresentationOf} (x) \) \;
% %     \eIf{\( b_1 \neq 00 \)}{
% %         \Return{}
% %         }{
% %         \( \boldsymbol{mb} \gets (b_2, ..., b_{31}) \) \;
% %         \For{\( i \gets 2 \) \KwTo $31$ \KwBy $1$}{
% %             \( c_i \gets \mathbf{Byte2Char} (b_i) \)}
% %         }
% %         \eIf{ all \( c_i \in \mathbb{C} \)}{
% %             \( m = (c_2, ..., c_{31}) \) }{
% %             \Return{}}
% %     \Return{\( m \)} \tcp*{\( m \in \mathbb{C}^* \)}
% % \end{algorithm}
% % \end{figure}

% % \begin{algorithm}[H]
% % \floatname{algorithm}{Point2String}
% % \renewcommand{\thealgorithm}{}
% % \caption{Algorithm for mapping an elliptic curve point to a string}
% % \begin{algorithmic}[1]
% % \STATE Set bytes \( \boldsymbol{b_\mathrm{x}} = ( b_1, ..., b_{32}) \leftarrow \mathbf{ByteRepresentationOf}(x) \)
% % \STATE If \( b_1 \neq 00 \), return
% % \STATE Set message bytes \( \boldsymbol{b_\mathrm{m}} = (b_2, ..., b_{31}) \)
% % \STATE Convert bytes to string \( m = \mathbf{Bytes2String}(\boldsymbol{b_\mathrm{m}}) \)
% % \STATE If $m$ is a valid string, return $m$. Else, return.
% % \end{algorithmic}
% % \end{algorithm} 

% Depending on the election type (referendum, simple election, multiple choice election, STV election), the text $m$ can be constructed in different ways. We recall from section \ref{mapping messages on EC} that $m$ can be maximum 30 characters in length. 

% For convenience, we will describe the case of a simple election where the voters have to select one candidate only. Each candidate must have a distinct name which will be used as $m$ and it can be at most 30 characters in length. All names are turned into elliptic curve points using the $\textbf{String2Point}$ algorithm. When decoded back from an elliptic curve point, the candidate name will be visible in plain text.

% \subsection{Election Phase}
% \subsubsection{Voter authentication procedure}

% The (result/conclusion) of a \textit{Voter} $\mathcal{V}_i$ being authenticated is being in possession of a secret signing key \( x_i \) that corresponds to an eligible public key \( Y_i \) from the bulletin board.

% \paragraph{\textit{Pre-election:}}
% \textit{Voter} $\mathcal{V}_i$ inputs in the browser all credentials received from the printing authorities $x_{i, j}$, with \( j \in \{ 1, ..., n_\mathrm{p} \} \). The browser combines all credentials to form the voter's secret signing key \( x_i = \sum_{j=1}^{n_\mathrm{p}} x_{i, j} \pmod q \). The associated public key \( Y_i \) has been computed and included on the bulletin board in the pre-election phase.

% \paragraph{\textit{On-demand:}}

% \begin{enumerate}
%     \item  When a \textit{Voter} $\mathcal{V}_i$ wants to vote the \textit{Voter Authorization Service} $\mathcal{A}$ requests all \textit{Identity Providers} $\boldsymbol{\mathcal{I}}$ to request identity validation from the \textit{Voter} $\mathcal{V}_i$.
%     \item On successful authentication, each \textit{Identity Provider} $\mathcal{I}_j$ creates an identity token $\sigma_{\mathrm{id}, j} \leftarrow \mathbf{Sign}_{x_{\mathcal{I}_j}}(\mathcal{V}_i)$ (algorithm \ref{alg: sign}) and shares it with the voter.
%     %\item The \textit{Identity Provider} $\mathcal{I}$ certifies the authenticity of the identity token by a \textit{Schnorr signature}  $\sigma_\mathrm{id} \leftarrow \mathbf{Sign}_{x_{\mathrm{I}_j}}(\mathcal{V}_i)$ (algorithm \ref{alg: sign})
%     \item Then, the \textit{Voter} $\mathcal{V}_i$ generates a key pair \( (x_i, Y_i) \leftarrow \mathbf{KeyGen}() \) and forwards all identity tokens \( (\sigma_{\mathrm{id}, 1}, ..., \sigma_{\mathrm{id}, n_\mathrm{i}}) \) and the public key $Y_i$ to the \textit{Voter Authorization Service} $\mathcal{A}$.
%     \item If all identity tokens can be verified by \( \mathbf{VerifySignature}_{Y_{\mathcal{I}_j}} (\sigma_\mathrm{id}, \mathcal{V}_i) \) (algorithm \ref{alg: verify sig}) then the \textit{Voter Authorization Service} $\mathcal{A}$ checks that the \textit{Voter} $\mathcal{V}_i$ is a eligible voter \( \mathcal{V}_i \in \boldsymbol{\mathcal{V}} \).
%     \item If a \textit{Voter} $\mathcal{V}_i$ is eligible then, the \textit{Voter Authorization Service} $\mathcal{A}$ generates an authorization token $\sigma_\mathrm{auth} \leftarrow \mathbf{Sign}_{x_\mathcal{A}}(vID || h_\mathrm{id})$ and a public key token  $\sigma_\mathrm{pk} \leftarrow \mathbf{Sign}_{x_\mathcal{A}}(vID || Y_i || h_\mathrm{id})$, where $vID$ is an internally used id for the \textit{Voter} $\mathcal{V}_i$ and $h_\mathrm{id} \leftarrow \mathcal{H}(\sigma_{\mathrm{id}, 1} || ... || \sigma_{\mathrm{id}, n_\mathrm{i}})$ is a fingerprint to all the tokens that confirm the identity of the voter.
%     \item The \textit{Voter Authorization Service} $\mathcal{A}$ returns the authentication token $\sigma_\mathrm{auth}$ and the public key token $\sigma_\mathrm{pk}$ to the \textit{Voter} $\mathcal{V}_i$.
%     \item The \textit{Voter} $\mathcal{V}_i$ submits these two tokens to the \textit{Digital Ballot Box} $\mathcal{D}$. The \textit{Digital Ballot Box} $\mathcal{D}$ then appends two items on the bulletin board which are the voter registration item and voter session item.
    
%     The voter registration item's parent is the latest election configuration and the voter session item's parent is the voter registration item. The voter registration item contains (???) and the voter session item contains (????)
    
%     Only the first time a voter authenticates himself in an election is a registration item created, if a voter has previously been authenticated only a voter session item is created.
%     \item The voter session and voter registration item is also returned to the user as a confirmation to his authentication. These items are also needed for the user to generate a vote cryptogram as it references the registration item and session item.
% \end{enumerate}

% \noindent The \textit{Voter Authorization Service} $\mathcal{A}$ stores a link between the voter identity $\mathcal{V}_i$, all related identity tokens, the authentication token, and the public key token. This is stored for the private auditing process in the post-election phase as described in \cref{sec:private_auditing_process}. The link is stored by the \textit{Voter Authorization Service} $\mathcal{A}$ due to the fact that the identity tokens likely contain personal information that must not be disclosed on the public bulletin board.

% \subsubsection{Voting Procedure}
% %The election phase lasts from the election start date until the election end date. During this time, each voter \( \mathcal{V}_j \in \boldsymbol{\mathcal{V}} \) can authenticate using the credentials received over different communication channels from different printing authorities and can participate in the voting process which consists of multiple steps:
% The election phase lasts from the election start date until the election end date. Each voter \( \mathcal{V}_i \in \boldsymbol{\mathcal{V}} \) has to be authenticated which varies depending on which voter registration mode is used. The \textit{Voter} $\mathcal{V}_i$ is authenticated when he is in possession of a private key \( x_i \) and the \textit{Digital Ballot Box} $\mathcal{D}$ is in possession of the corresponding public key \( Y_i \). 
 
%     %\( \mathbf{Sign}_{x_j} (h_\mathrm{v}) \)
%     %which the user can use to cast his/her vote.
%     %returns a signed confirmation token "ct=sign(<contact\_info><time>,OTP\_privateKey)"
%     %"at=sign(<voter\_id><pub\_key>,VA\_privKey)"

% \begin{enumerate}
% %    \item The browser tries to authenticate the \textit{Voter} $\mathcal{V}_i$ to the \textit{Bulletin Board} $\mathcal{D}$ \( \mathbf{VerifySignature}_{Y_\mathcal{A}} (\sigma_\mathrm{auth}, vID || h_\mathrm{id}) \). 
%     \item The voter asks the \textit{Digital Ballot Box} $\mathcal{D}$ for the latest election configuration item which defines the election options.
    
%     \item The \textit{Voter} $\mathcal{V}_i$ picks a vote option $m$ and the browser converts it into an elliptic curve point \( M \leftarrow \mathbf{String2Point}(m) \) (algorithm \ref{alg: string to point}). Next, the browser collaborates with the \textit{Digital Ballot Box} $\mathcal{D}$ in the \textit{vote cryptogram generation process} in order to encrypt the \textit{Voter} $\mathcal{V}_i$'s choice. This process is described in section \ref{vote cryptogram generation}. At the end of this step, the vote cryptogram $e$ is published to the bulletin board together with the two encryption commitments.
    
%     \item At this point, the \textit{Voter} $\mathcal{V}_i$ has two options. If he has enough trust in the voting application, the \textit{Voter} $\mathcal{V}_i$ can register the vote cryptogram $e$ on the bulletin board (the process continues on the next bullet point). Otherwise, the \textit{Voter} $\mathcal{V}_i$ has the option to challenge the vote cryptogram (verify that it actually contains the vote $m$), process described in section \ref{encryption challenge}.
%     If the \textit{Voter} $\mathcal{V}_i$ chooses to challenge the cryptogram he has to recast/regenerate his vote (return to previous bullet point 2) and he can repeat this process as many times as needed until he gains enough trust in the voting application and can continue in the process (bullet point 4).
    
%     %\item The browser asks the \textit{Bulletin Board} $\mathcal{D}$ for the latest hash value of the board $h_\mathrm{a}$, which we call \textit{the acknowledged hash}. The browser computes the vote's content hash $h_\mathrm{v} = \mathcal{H}(s)$, where $s$ is a message containing the following information: the voter id, the election id, the vote cryptogram $e$, the acknowledged hash $h_\mathrm{a}$ and the acknowledged time stamp.
    
%     \item The \textit{Voter} $\mathcal{V}_i$ generates his cast request item which references the vote cryptogram item. The \textit{Voter} $\mathcal{V}_i$ then send the cast request item to the \textit{Digital Ballot Box} $\mathcal{D}$.
    
%     \item The browser certifies the authenticity of the vote cryptogram by generating a response (signature) of the \textit{Voter} $\mathcal{V}_i$ on the vote's content hash as a \textit{Schnorr signature} \( \sigma \leftarrow \mathbf{Sign}_{x_i} (h_\mathrm{v}) \) (algorithm \ref{alg: sign}). The browser submits to the \textit{Digital Ballot Box} $\mathcal{D}$ the following: the vote cryptogram $e$, the proof of correct encryption $PK$, the vote content hash $h_\mathrm{v}$ and the signature $\sigma$. The last response from the \textit{Digital Ballot Box} $\mathcal{D}$ that the \textit{Voter} $\mathcal{V}_i$ receives which certifies the acceptance of the cast request item on the board should be regarded as a vote receipt.

% \end{enumerate}

% \clearpage
% \subsubsection{Vote cryptogram generation process}
% During the vote cryptogram generation process, the voter's browser collaborates with the \textit{Digital Ballot Box} $\mathcal{D}$ for generating the cryptogram. This process results in the fact that the \textit{Voter} $\mathcal{V}_i$ will not be in possession of the randomizer value used in the cryptogram $e$. That is achieved by both the browser and the \textit{Digital Ballot Box} $\mathcal{D}$ building up the randomizer but none of them knowing its entire value. It is important for the \textit{Voter} $\mathcal{V}_i$ not to know this value so he cannot produce cryptographic evidence of the way he voted (as in section \ref{prove cryptogram}), thus enforcing \textit{receipt freeness}. The vote cryptogram generation process is described in figure \ref{fig: vote cryptogram generation}.

% %The process starts with the \textit{Bulletin Board} $\mathcal{D}$ delivering to the \textit{Voter} $\mathcal{V}_i$ an empty cryptogram (an encryption of the neutral point $\mathcal{O}$) \( e_0 \gets \mathbf{Enc} (\mathcal{O}, r_0) \) (algorithm \ref{alg: enc}), where \( r_0 \in_\mathrm{R} \mathbb{Z}_q \). 

% The process starts with the \textit{Voter} $\mathcal{V}_i$ encrypting his vote $M$ with the randomizer \( r_1 \in_\mathrm{R} \mathbb{Z}_q \) by generating the cryptogram \( e_1 \gets \mathbf{Enc}_{Y_\mathrm{enc}} (M, r_1) \) (algorithm \ref{alg: enc}). The commitment ($r_1$) is sent to the \textit{Digital Ballot Box} $\mathcal{D}$ which then generates an empty cryptogram (an encryption of the neutral point $\mathcal{O}$) \( e_0 \gets \mathbf{Enc} (\mathcal{O}, r_0) \) (algorithm \ref{alg: enc}), where \( r_0 \in_\mathrm{R} \mathbb{Z}_q \). \textit{Digital Ballot Box} $\mathcal{D}$ then publishes its own and the voters commitment ($r_0$ \& $r_1$) to the bulletin board. The empty cryptogram is then sent back to the voter as well as the item for the voter and board commitment. The \textit{Voter} $\mathcal{V}_i$ finalizes the cryptogram by homomorphically adding his cryptogram to the empty cryptogram received from the server \( e = \mathbf{AddEnc}(e_0, e_1) \) (algorithm \ref{alg: add enc}). The \textit{Voter} $\mathcal{V}_i$ also generates a proof of correct encryption \( PK \gets \mathbf{Prove}_G (r_1) \) (algorithm \ref{alg: Prove dl}). The finalized cryptogram is sent to the \textit{Digital Ballot Box} $\mathcal{D}$ and published on the bulletin board.
% %the \textit{Bulletin Board} $\mathcal{D}$ delivering to the \textit{Voter} $\mathcal{V}_i$ an empty cryptogram (an encryption of the neutral point $\mathcal{O}$) \( e_0 \gets \mathbf{Enc} (\mathcal{O}, r_0) \) (algorithm \ref{alg: enc}), where \( r_0 \in_\mathrm{R} \mathbb{Z}_q \). 

% %Next, $\mathcal{D}$ starts an \textit{interactive zkp of discrete logarithm equality}, as in figure \ref{fig:DLE_protocol}, in order to prove to $\mathcal{V}_j$ that $e_0$ is indeed an empty cryptogram. Formally, 
% %\[
% %PK_0 = PK[(r_0): R_0 = [r_0]G \wedge C_0 = [r_0]Y].
% %\]

% %The reason $PK_0$ needs to be an \textit{interactive proof} is that $PK_0$ does not need to be universally valid. Instead, only the \textit{Voter} $\mathcal{V}_i$ needs to be convinced that $e_0$ is an empty cryptogram.

% %Next, the \textit{Voter} $\mathcal{V}_i$ builds his vote cryptogram on top of the empty cryptogram that he just received. Formally, the \textit{Voter} $\mathcal{V}_i$ encrypts his vote $M$ with the randomizer \( r_1 \in_\mathrm{R} \mathbb{Z}_q \) by generating the cryptogram \( e_1 \gets \mathbf{Enc}_{Y_\mathrm{enc}} (M, r_1) \) (algorithm \ref{alg: enc}), which he needs to homomorphically add to the empty cryptogram in order to generate his final vote cryptogram \( e = \mathbf{AddEnc}(e_0, e_1) \) (algorithm \ref{alg: add enc}). The \textit{Voter} $\mathcal{V}_i$ also generates a proof of correct encryption \( PK \gets \mathbf{Prove}_G (r_1) \) (algorithm \ref{alg: Prove dl}).

% Note that now, the cryptogram $e$ is actually \( \mathbf{Enc}_{Y_\mathrm{enc}} (M, r_0 + r_1) \). Both the \textit{Voter} $\mathcal{V}_i$ and the \textit{Digital Ballot Box} $\mathcal{D}$ know part of the randomizer value \( r_0 + r_1 \) (the voter knows $r_1$ and the \textit{Digital Ballot Box} $\mathcal{D}$ knows $r_0$) but neither of them knows the full value.

% When submitting his vote, the \textit{Voter} $\mathcal{V}_i$ sends both the cryptogram \( e = (R, C) \) and the proof of correct encryption $PK$. The \textit{Digital Ballot Box} $\mathcal{D}$ accepts the vote cryptogram if the proof validates \( \mathbf{Verify}_G (PK, R - R_0) \) (algorithm \ref{alg: Verify dl}). This proves that the \textit{Voter} $\mathcal{V}_i$ did use the empty cryptogram $e_0$ in the construction of the vote cryptogram $e$, thus ensuring that the \textit{Voter} $\mathcal{V}_i$ does not know the randomness value of his cryptogram.

% % \begin{figure}[h]
% %     \centering
% %     \begin{tikzpicture}[framed]
% %         \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
% %             \textbf{Voter $\mathcal{V}_j$} & & \textbf{Bulletin Board $\mathcal{D}$} \\ 
% %             /*knows $x_j, M$*/ & & /*knows \( \boldsymbol{Y} = (Y_1, ..., Y_{n_\mathrm{v}}) \)*/ \\ [2mm]
% %             & & \scriptsize /*generate empty cryptogram*/ \\ [-1mm]
% %             & & \( r_0 \in_R \mathbb{Z}_q \) \\
% %             & & \( e_0 = (R_0, C_0) \gets \mathbf{Enc}_{Y_\mathrm{enc}} (\mathcal{O}, r_0) \) \\
% %             & send $e_0$ & \\ [5mm]
% %             &|[multicol=3]|$\mathcal{V}_j$ and $\mathcal{D}$ participate in the protocol for & \\
% %             &|[multicol=3]|proving the multiple discrete logarithms & \\
% %             &|[multicol=3]|\(PK_0 = PK[(r_0): R_0 = [r_0]G \wedge C_0 = [r_0]Y] \) & \\
% %             &|[multicol=3]|from figure \ref{fig:DLM_protocol}, where $\mathcal{D}$ is the prover & \\
% %             &|[multicol=3]|and $\mathcal{V}_j$ is the verifier (proof that $e_0$ is empty). & \\ [5mm]
% %             \( r_1 \in_R \mathbb{Z}_q \) & & \\
% %             \( e_1 \gets \mathbf{Enc}_{Y_\mathrm{enc}} (M, r_1) \) & & \\ [2mm]
% %             \scriptsize /*vote cryptogram*/ & & \\ [-1mm]
% %             \( e \gets \mathbf{AddEnc} (e_0, e_1) \) & & \\ [2mm]
% %             \scriptsize /*proof of correct encryption*/ & & \\ [-1mm]
% %             \( PK \gets \mathbf{Prove}_G (r_1) \) & & \\
% %             % & send $e, PK_1$ & \\
% %             % & & if \( \mathbf{Verify}_G (PK_1, R - R_0) \) \\
% %             % & & -- accept cryptogram $e$ \\
% %         };
% %         \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
% %         \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
% %         \draw[-latex] (m-6-2.south east)--(m-6-2.south west);
% %         % \draw[-latex] (m-16-2.south west)--(m-16-2.south east);
% %         \draw[dashed, shorten <= -6cm, shorten >= -1cm] (m-7-2.north west)--(m-7-2.north east);
% %         \draw[dashed, shorten <= -6cm, shorten >= 0cm] (m-11-2.south west)--(m-11-2.south east);
% %     \end{tikzpicture}
% %     \caption{Protocol for generating a vote cryptogram}
% % \end{figure}

% \begin{figure}[h]
%     \centering
%     \begin{tikzpicture}[framed]
%         \matrix (m) [matrix of nodes, nodes = {draw = none, anchor = base west, align = left, text depth = 0pt} ]{
%             \textbf{Voter $\mathcal{V}_i$} & & \textbf{Digital Ballot Box} $\mathcal{D}$ \\ 
%             /*knows $x_j, M$*/ & & /*knows \( \boldsymbol{Y} = (Y_1, ..., Y_{n_\mathrm{v}}) \)*/ \\ [2mm]
%             & & \scriptsize /*generate empty cryptogram*/ \\ [-1mm]
%             & & \( r_0 \in_\mathrm{R} \mathbb{Z}_q \) \\
%             & & \( e_0 = (R_0, C_0) \gets \mathbf{Enc}_{Y_\mathrm{enc}} (\mathcal{O}, r_0) \) \\
%             & send $e_0$ & \\ [3mm]
%             & & \scriptsize /*$\mathcal{D}$ starts the protocol for proving to $\mathcal{V}_i$ \\
%             % \scriptsize /*$\mathcal{D}$ starts the protocol for proving & \scriptsize to $\mathcal{V}_j$ & \scriptsize fds  \\
%             & & \scriptsize that $e_0$ is an empty cryptogram. \\ 
%             & & \scriptsize protocol from figure \ref{fig:DLE_protocol}*/ \\ [2mm]
%             & & \( k \in_\mathrm{R} \mathbb{Z}_q \) \\
%             & & \( K_\mathrm{G} \gets [k]R_0 \), \( K_\mathrm{Y} \gets [k]C_0 \) \\
%             & send $K_\mathrm{G}$, $K_\mathrm{Y}$ & \\
%             \( c \in_\mathrm{R} \mathbb{Z}_q \) & & \\
%             & send $c$ & \\
%             & & \( z \gets k + c \cdot r_0 \pmod q \) \\
%             & send $z$ & \\
%             \( [z]G \stackrel{?}{=} K_\mathrm{G} + [c]R_0 \) & & \\
%             \( [z]Y_\mathrm{enc} \stackrel{?}{=} K_\mathrm{Y} + [c]C_0 \) & & \\ [4mm]
%             \scriptsize /*when $\mathcal{V}_i$ accepts the proof & & \\ 
%             \scriptsize protocol from figure \ref{fig:DLE_protocol} ends*/ & & \\ [3mm]
%             \scriptsize /*proof of empty cryptogram*/ & & \\ [-1mm]
%             \( PK_0 \gets (K_\mathrm{G}, K_\mathrm{Y}, c, z) \) & & \\ [2mm]
%             \( r_1 \in_\mathrm{R} \mathbb{Z}_q \) & & \\
%             \( e_1 \gets \mathbf{Enc}_{Y_\mathrm{enc}} (M, r_1) \) & & \\ [2mm]
%             \scriptsize /*vote cryptogram*/ & & \\ [-1mm]
%             \( e \gets \mathbf{AddEnc} (e_0, e_1) \) & & \\ [2mm]
%             \scriptsize /*proof of correct encryption*/ & & \\ [-1mm]
%             \( PK \gets \mathbf{Prove}_G (r_1) \) & & \\
%             % & send $e, PK_1$ & \\
%             % & & if \( \mathbf{Verify}_G (PK_1, R - R_0) \) \\
%             % & & -- accept cryptogram $e$ \\
%         };
%         \draw[shorten <= -0.5cm] (m-1-1.south east)--(m-1-1.south west);
%         \draw[shorten <= -0.5cm] (m-1-3.south east)--(m-1-3.south west);
%         \draw[-latex] (m-6-2.south east)--(m-6-2.south west);
%         \draw[-latex] (m-12-2.south east)--(m-12-2.south west);
%         \draw[-latex] (m-14-2.south west)--(m-14-2.south east);
%         \draw[-latex] (m-16-2.south east)--(m-16-2.south west);
%         \draw[dashed, shorten <=-6.5cm, shorten >=-2cm] (m-9-3.south west)--(m-9-3.south east);
%         \draw[dashed, shorten <=0cm, shorten >=-7.5cm] (m-19-1.north west)--(m-19-1.north east);
%     \end{tikzpicture}
%     \caption{Protocol for generating a vote cryptogram}
% \end{figure}

% % \begin{algorithm}[H]
% % \floatname{algorithm}{VoteCryptogramGeneration}
% % \renewcommand{\thealgorithm}{}
% % \caption{Protocol for generating a vote cryptogram}
% % \begin{algorithmic}[1]
% % \STATE Bulletin board : Computes an empty cryptogram \( e_0 = (R_0, C_0) \leftarrow \mathbf{Enc}_{Y_\mathrm{enc}} (\mathcal{O}, r_0) \), where \( r_0 \in_R \mathbb{Z}_q \), and sends it to the voter.
% % \STATE Bulletin board + Browser : Participate in the protocol for generating a proof of empty cryptogram in form of a discrete logarithm interactive zero knowledge proof \( PK_0 \leftarrow \mathbf{Prove}_{G, Y_\mathrm{enc}} (r_0) \).
% % \STATE Browser : Verifies proof \( b \leftarrow \mathbf{Verify}_{G, Y_\mathrm{enc}} (PK_0, R_0, C_0) \). If the proof validates, the browser continues the process.
% % \STATE Browser : Encrypts the voting choice \( M \in \boldsymbol{M} \) and homomorphically combines it with the empty cryptogram received from the bulletin board to form the final vote cryptogram \( e_1 = (R_1, C_1) \leftarrow \mathbf{AddEnc} (e_0, \mathbf{Enc}_{Y_\mathrm{enc}} (M, r_1)) \), where \( r_1 \in_R \mathbb{Z}_q \).
% % \STATE Browser : Generates a proof that the empty cryptogram was used in the voting process (proof of correct encryption) in form of a discrete logarithm non-interactive zero knowledge proof \( PK_1 \leftarrow \mathbf{Prove}_G (r_1) \).
% % \STATE Bulletin board : To accept the vote cryptogram $e_1$, the bulletin board has to validate the proof of correct encryption \( \mathbf{Verify}_G (PK_1, R_1 - R_0) \).
% % \end{algorithmic}
% % \end{algorithm} 


% % After the vote cryptogram has been registered and published on the bulletin board, the voter receives a confirmation receipt $\rho$ that can be used later to verify that her vote is registered correctly on the bulletin board and to verify that the hash values of the bulletin board are consistent.

% \clearpage
% \subsubsection{Challenging a vote cryptogram}
% By challenging a vote cryptogram we are checking whether the \textit{voting application} is honest or not. In other words, we check whether the \textit{Voter} $\mathcal{V}_i$'s browser is under control of an attacker who tries to cast a different vote than the \textit{Voter} $\mathcal{V}_i$'s option.

% In order to challenge a vote cryptogram $e$, the browser asks the \textit{Digital Ballot Box} $\mathcal{D}$ for the randomizer value $r_0$ used to generate the empty cryptogram $e_0$. Recall from previous section that the browser knows the value $r_1$ used in the generation of $e$.

% Next, following the \textit{Benaloh challenge} paradigm \cite{Benaloh06}, it will print on the screen (as a QR code or readable format) the vote cryptogram $e = (R, C)$, the encryption key $Y_\mathrm{enc}$ and the entire randomizer value \( r = r_0 + r_1 \). All this information must be transferred to another device that the \textit{Voter} $\mathcal{V}_i$ \textbf{trusts} and that is able to perform the decryption algorithm. Next, the \textit{Voter} $\mathcal{V}_i$ needs to verify that the information on the device is identical to the one from the voting application.

% If the information matches, the \textbf{trusted} device can perform the decryption by extracting the vote \( M \gets \mathbf{Dec}_r(e') \) (algorithm \ref{alg: dec}), where \( e' = (Y_\mathrm{enc}, C) \). Note that we apply the decryption algorithm on a modified cryptogram where value $R$ and $Y_\mathrm{enc}$ are swapped. That is done because we are trying to decrypt using the randomizer instead of the decryption key. 

% Next, the vote is interpreted as plain text \( m \gets \mathbf{Point2String} (M) \). If $m$ corresponds to the \textit{Voter} $\mathcal{V}_i$'s choice, this proves that the voting application has behaved correctly in the vote encryption process. If there are any differences in the process described above, it means that the voting application has tried to cheat and is now caught.

% We argue that, in case the voting application is corrupt and tries to cheat, the procedure of \textit{challenging a vote cryptogram} will discover the cheating attempt with overwhelming probability. 

% Let's say that the voting application uses the fake option $m'$ instead of $m$ in the process of generating the vote cryptogram. That generates \( e' = (R, C) \gets \mathbf{AddEnc} (e_0, e_1) \), where \( e_1 \gets \mathbf{Enc}_{Y_\mathrm{enc}} (M', r_1) \) and \( M' \gets \mathbf{String2Point} (m') \). Now, to cheat the \textbf{trusted} device that $e'$ is an encryption of $m$, it needs to print on the screen as the value of the randomizer \( r' \gets r_0 + r_1 - \Delta_\mathrm{m} / x_\mathrm{enc} \), where \( [\Delta_\mathrm{m}]G = M - M' \) and $x_\mathrm{enc}$ is the decryption key.

% In conclusion, for the voting application to cheat the \textbf{trusted} device, it needs not only the secret decryption key $x_\mathrm{enc}$ but also, to break the Elliptic Curve Discreet Logarithm Problem in order to find $\Delta_\mathrm{m}$, which we consider \textit{infeasible}.

% \clearpage

% \clearpage
% \subsubsection{Vote Confirmation Receipt}
% Once the vote cryptogram $e_i$ has been registered, the \textit{Voter} $\mathcal{V}_i$ receives back from the \textit{Digital Ballot Box} $\mathcal{D}$ a confirmation receipt in form of a Schnorr signature (algorithm \ref{alg: sign}) \( \rho_i = \mathbf{Sign}_{x_\mathrm{sign}} (\sigma_i || h_{\mathrm{b},i}) \), together with the new board hash value $h_{\mathrm{b},i}$, the previous board hash value $h_{\mathrm{b},i-1}$ and the registration time stamp $t_{\mathrm{r},i}$. Recall from section \ref{pre-election phase} that $x_\mathrm{sign}$ is the \textit{Digital Ballot Box} $\mathcal{D}$'s signing key.

% The receipt certifies that the vote cryptogram has been registered on the bulletin board at exactly version $h_{\mathrm{b},i}$. The \textit{Voter} $\mathcal{V}_i$ can use this receipt to verify, at any time, that her vote is included on the board, and that the history of the board has not changed by validating the hash value. 

% If the previous board hash value $h_{\mathrm{b},i-1}$ does not match with the acknowledged hash $h_{\mathrm{a},i}$, that means a "race" situation (described in the previous section) has happened and the current \textit{Voter} $\mathcal{V}_i$ has lost the race, i.e. while the current \textit{Voter} $\mathcal{V}_i$ was preparing her vote submission, another \textit{Voter} $\mathcal{V}_i$ has successfully managed to post another vote submission. This is a perfectly valid scenario that can occur in busy situations.

% Note that, if a \textit{Voter} $\mathcal{V}_i$ has a confirmation receipt that does not correspond with the current state of the bulletin board, that immediately reveals an attempt to break the integrity of the bulletin board and should be reported to the election authorities.

% \clearpage
% \subsection{Post-election Phase}
% After the voting time has finished, the election proceeds to the last phase which will generate the result of the election. Now, the \textit{Digital Ballot Box} $\mathcal{D}$ does not accept any new vote cryptograms anymore. The list of votes remains publicly available for voters to check that their vote cryptogram is included (using their confirmation receipt) and for auditors to check that the hash values of the list are consistent (the integrity of the board is persistent).

% In this chapter we will present all the steps that take place in the post-election phase.

% \subsubsection{Cleansing Procedure}
% The \textit{Digital Ballot Box} $\mathcal{D}$ will create a different list that contains only the cryptograms of the \textit{valid cryptograms} from the bulletin board. A \textit{valid cryptogram} is a vote cryptogram item on the bulletin board that has a valid signature and that has not been overwritten by a latter vote cryptogram generated by the same voter.

% % Rephrase above.

% The new list of cryptograms is called \textit{the initial mixed board} and is saved in a file. This file will be used as the input to the \textit{mixing phase}.

% The cleansing procedure is publicly auditable as both the list of vote cryptograms and the initial mixed board are publicly available.

% \subsubsection{Mixing Phase}
% During the mixing phase, the list of cryptograms will change its appearance several times, being shuffled in an indistinguishable way. Each mixer from the mixnet \( \mathcal{M}_i \in \boldsymbol{\mathcal{M}} \) applies its mixing algorithm in sequential order (the output of $\mathcal{M}_{i-1}$ will be used as input for $\mathcal{M}_i$). The first mixer $\mathcal{M}_1$ applies its algorithm on \textit{the initial mixed board} and the output of the last mixer $\mathcal{M}_{n_\mathrm{m}}$ is used as \textit{the final mixed board}.

% Obviously, each mixer $\mathcal{M}_i$ knows the shuffling coefficients of its own mixing algorithm and it is able to link the votes on the mixed board at step $i - 1$ (input board) with the ones on the mixing board at step $i$ (output board). However, $\mathcal{M}_i$ does not know the shuffling coefficients of the other mixers algorithms so it cannot create a full link between the votes on the final mixed board and the ones on the initial mixed board, unless all mixers are corrupt and collude against the election. It is important this full link to be unknown because the votes on the initial mixed board can be associated with an identity (through its digital signature).

% Thus, on the assumption that at least one mixer is honest, during the mixing phase the link between a vote on the final mixed board and its owner (voter) is broken. Therefore, mixing phase preserves anonymity.

% Each mixer \( \mathcal{M}_i \in \boldsymbol{\mathcal{M}} \) asks the \textit{Digital Ballot Box} $\mathcal{D}$ for the latest version of the mixed board. The \textit{Digital Ballot Box} $\mathcal{D}$ will grant permission to one mixer at a time. When $\mathcal{M}_i$ is granted permission, it receives the mixed board $\boldsymbol{e_{i-1}}$. Next, $\mathcal{M}_i$ follows the mixing procedure to compute the new mixed board by randomly permuting the entire list of cryptograms and re-encrypting each cryptogram from the permuted list with distinct randomnizers. Finally, $\mathcal{M}_i$ computes a proof of correct mixing in form of Furukawa's Proof of Shuffle \( (\boldsymbol{e_i}, PK) \leftarrow \mathbf{MixingProcedure}_{Y_\mathrm{enc}} (\boldsymbol{e_{i-1}}) \) described in algorithm \ref{alg: mix}.

% We recall from section \ref{furukawa proof} that the algorithm used for proving a shuffle has the soundness property on the assumption that the prover is not in the possession of the randomizers used in the generation of each cryptogram. We consider this assumption sane as the cryptograms are generated in collaboration between the \textit{Digital Ballot Box} $\mathcal{D}$ and each voter (figure \ref{fig: vote cryptogram generation}). By following this protocol, we ensure that there is no single entity that knows the randomizer value behind any cryptogram. 

% % \begin{figure}
% \begin{algorithm}[!h]
% \DontPrintSemicolon
%     \caption{\( \mathbf{MixingProcedure}_{Y_\mathrm{enc}} (\boldsymbol{e_{i-1}}) \)}
%     \KwData{The input mixed board \( \boldsymbol{e_{i-1}} \in \mathbb{E}^n \)}
%     \( \boldsymbol{r} \in_\mathrm{R} \mathbb{Z}_q^n \) \;
%     \( \psi \in_\mathrm{R} \Psi_n \) \;
%     \tcc{compute new mixed board}
%     \( \boldsymbol{e_i} \gets \mathbf{Shuffle}_{Y_\mathrm{enc}} (\boldsymbol{e_{i-1}}, \boldsymbol{r}, \psi) \) \tcp*{algorithm \ref{alg: shuffle}}
%     \tcc{compute shuffle proof}
%     \( PK \gets \mathbf{ProveShuffle}_{Y_\mathrm{enc}} (\boldsymbol{e_{i-1}}, \boldsymbol{r}, \psi) \) \tcp*{algorithm}
%     \Return{\( (\boldsymbol{e_i}, PK) \)} \tcp*{\( (\boldsymbol{e_i}, PK) \in \mathbb{E}^n \times (E(\mathbb{F}_p)^{8 + 4 \cdot n} \times \mathbb{Z}_q^n \times \mathbb{Z}_q^{2+n}) \)}
% \end{algorithm}
% % \end{figure}

% Note that, while one mixer applies its mixing algorithm on a mixing board, the other mixers have to wait until the new mixing board has been approved.

% % \begin{algorithm}[H]
% % \floatname{algorithm}{MixingProcedure}
% % \renewcommand{\thealgorithm}{}
% % \caption{Procedure for applying mixing algorithm on a mixed board}
% % \begin{algorithmic}[1]
% % \STATE Mixer : Extracts $n_\mathrm{e}$ as the cardinality of the list $\boldsymbol{e_{i-1}}$
% % \STATE Mixer : Generates randomizers \( \boldsymbol{r} = (r_1, ..., r_{n_\mathrm{e}}) \in_R \mathbb{Z}_q^{n_\mathrm{e}} \)
% % \STATE Mixer : Randomly picks permutation \( \psi \in_R \Psi_{n_\mathrm{e}} \)
% % \STATE Mixer : Computes new mixed board \( \boldsymbol{e_i} = \mathbf{Shuffle}_{Y_\mathrm{enc}} (\boldsymbol{e_{i-1}}, \boldsymbol{r}, \psi) \)
% % \STATE Mixer : Generates the mixing proof \( PK \leftarrow \mathbf{ProveShuffle}_{G, Y_\mathrm{enc}} (\boldsymbol{e_{i-1}}, \boldsymbol{r}, \psi)
% % \)
% % \end{algorithmic}
% % \end{algorithm} 

% Once the mixing procedure has finished, both the mixed board $\boldsymbol{e_i}$ and the mixing proof $PK$ are saved in separate files. The mixer uploads both files to the \textit{Digital Ballot Box} $\mathcal{D}$ which checks the validity of the proof by running the algorithm \( \mathbf{VerifyShuffle}_{Y_\mathrm{enc}} (PK, \boldsymbol{e_{i-1}}, \boldsymbol{e_i}) \) (algorithm \ref{alg: verify shuffle}). If the proof validates, the \textit{Digital Ballot Box} $\mathcal{D}$ accepts $\boldsymbol{e_i}$ as the new version of the mixed bulletin board.

% When all mixers have applied their mixing procedures, the final mixed bulletin board is used in the decryption phase to compute the election results.

% % \clearpage
% \subsubsection{Decryption Phase}
% Because the link between a vote cryptogram and its \textit{Voter} $\mathcal{V}_i$ has been broken during the mixing phase, it is safe now to decrypt all the cryptograms from the final mixed board as it does not violate the secrecy of the election. Furthermore, decrypting the final mixed board would lead to accurate and correct results as it contains the exact same votes as the initial bulletin board, fact proven by the mixing proofs.

% During the decryption phase, trustees have to collaborate again. This time, only a threshold of trustees are sufficient to decrypt the votes. The threshold value $t$ is the one set during the \textit{threshold ceremony}. Recall that each trustee \( \mathcal{T}_i \in \boldsymbol{\mathcal{T}} \) is in possession of a share of the election decryption key $sx_i$.

% Assuming that the subset of trustees \( \boldsymbol{T} \subset \boldsymbol{\mathcal{T}} \) participate in the decryption phase, with the cardinality of $\boldsymbol{T}$ being \( n_\mathrm{d} \geq t \). Each trustee \( \mathcal{T}_i \in \boldsymbol{T} \) downloads from the \textit{Digital Ballot Box} $\mathcal{D}$ the final mixed bulletin board \( \boldsymbol{e} = (e_1, ..., e_{n_\mathrm{e}}) \) and computes partial decryptions of every single cryptogram by following the algorithm \( \boldsymbol{S_i} = (S_{i,1}, ..., S_{i,n_\mathrm{e}}) \leftarrow \mathbf{PartialDecryption}_{sx_i} (\boldsymbol{e}) \) (algorithm \ref{alg: partial decryption}). 

% % \begin{figure}
% \begin{algorithm}[!h]
% \DontPrintSemicolon
%     \caption{\( \mathbf{PartialDecryption}_{sx_i} (\boldsymbol{e}) \)}
%     \KwData{The share of decryption key \( sx_i \in \mathbb{Z}_q \)}
%     \KwMoreData{The board of cryptograms \( \boldsymbol{e} = (e_1, ..., e_{n_\mathrm{e}}) \in \mathbb{E}^{n_\mathrm{e}}) \)}
%     \KwMoreData{\( e_j = (R_j, C_j), j \in \{ 1, ..., n_\mathrm{e} \} \)}
%     \For{\( j \gets 1 \) \KwTo $n_\mathrm{e}$ \KwBy $1$}{
%         \( S_{i, j} \gets [sx_i]R_j \)}
%     \( \boldsymbol{S_i} \gets (S_{i, 1}, ..., S_{i, n_\mathrm{e}}) \) \;
%     \Return{\( \boldsymbol{S_i} \)} \tcp*{\( \boldsymbol{S_i} \in E(\mathbb{F}_p)^{n_\mathrm{e}} \)}
% \end{algorithm}
% % \end{figure}

% % \begin{algorithm}[H]
% % \floatname{algorithm}{PartialDecryption}
% % \renewcommand{\thealgorithm}{}
% % \caption{Algorithm for computing partial decryptions}
% % \begin{algorithmic}[1]
% % \STATE Trustee $\mathcal{T}_i$ : For each \( e_j \in \boldsymbol{e} \), with \( e_j = (R_j, C_j) \), the trustee computes \( S_{i,j} = [sx_i]R_j \).
% % \end{algorithmic}
% % \end{algorithm} 

% After computing partial decryptions, trustee $\mathcal{T}_i$ generates a proof of correct decryption in form of a \textit{non-interactive Proof for Multiple Discrete Logarithms} (section \ref{multiple dle}) \( PK_i \leftarrow \mathbf{ProveMultiple}_{G, R_1, ..., R_{n_\mathrm{e}}} (sx_i) \) (algorithm \ref{alg: Prove dlm}). The trustee sends to the \textit{Digital Ballot Box} $\mathcal{D}$ both the partial decryptions $\boldsymbol{S_i}$ together with the proof of correct decryption $PK_i$. The \textit{Digital Ballot Box} $\mathcal{D}$ accepts the partial decryption $\boldsymbol{S_i}$ if the proof of correct decryption validates according to the algorithm \( \mathbf{VerifyMultiple}_{G, R_1, ..., R_{n_\mathrm{e}}} (PK_i, sY_i, S_{i,1}, ..., S_{i,n_\mathrm{e}}) \) (algorithm \ref{alg: Verify dlm}). Recall from section \ref{threshold ceremony} that trustee's public share of the decryption key $sY_i$ is publicly available.

% Upon receiving all partial decryptions \( (\boldsymbol{S_1}, ..., \boldsymbol{S_{n_\mathrm{d}}}) \) from all trustees in $\boldsymbol{T}$, the \textit{Digital Ballot Box} $\mathcal{D}$ aggregates all partial decryptions for each cryptogram \( e_j \in \boldsymbol{e} \) to finalize the decryption and extract the votes \( \boldsymbol{V} = (V_1, ..., V_{n_\mathrm{e}}) \). The procedure for aggregating all partial decryptions is described in the algorithm \( \boldsymbol{V} \leftarrow \mathbf{FinalizeDecryption} (\boldsymbol{e}, \boldsymbol{S_1}, ..., \boldsymbol{S_{n_\mathrm{d}}}) \) (algorithm \ref{alg: finalize decryption}).

% % \begin{figure}
% \begin{algorithm}[!h]
% \DontPrintSemicolon
%     \caption{\( \mathbf{FinalizeDecryption} (\boldsymbol{e}, \boldsymbol{S_1}, ..., \boldsymbol{S_{n_\mathrm{d}}}) \)}
%     \KwData{The board of cryptograms \( \boldsymbol{e} = (e_1, ..., e_{n_\mathrm{e}}) \in \mathbb{E}^{n_\mathrm{e}} \)}
%     \KwMoreData{\( e_j = (R_j, C_j), j \in \{ 1, ..., n_\mathrm{e} \} \)}
%     \KwMoreData{The partial decryptions \( \boldsymbol{S_i} = (S_{i, 1}, ..., S_{i, n_\mathrm{e}}) \in E(\mathbb{F}_p)^{n_e}, i \in \boldsymbol{T} \)}
%     \For{\( j \gets 1 \) \KwTo $n_\mathrm{e}$ \KwBy $1$}{
%         \( V_j \gets C_j - \sum_{i \in \boldsymbol{T}} [\lambda(i)]S_{i,j} \) \tcp*{\( \lambda(i) \) computed as in figure \ref{fig: threshold decryption}}
%         }
%     \( \boldsymbol{V} \gets (V_1, ..., V_{n_\mathrm{e}}) \) \;
%     \Return{\( \boldsymbol{V} \)} \tcp*{\( \boldsymbol{V} \in E(\mathbb{F}_p)^{n_\mathrm{e}} \)}
% \end{algorithm}
% % \end{figure}

% % \begin{algorithm}[H]
% % \floatname{algorithm}{FinalizeDecryption}
% % \renewcommand{\thealgorithm}{}
% % \caption{Algorithm for aggregating all partial decryptions}
% % \begin{algorithmic}[1]
% % \STATE Bulletin Board : For each \( e_j \in \boldsymbol{e} \), with \( e_j = (R_j, C_j) \), the bulletin board computes
% % \[ 
% % V_j = C_j - \sum_{i \in \boldsymbol{T}} [\lambda(i)]S_{i,j},
% % \]
% % where $\lambda(i)$ is the threshold coefficient of a trustee and it is computed as in section \ref{threshold ceremony}. Note that threshold coefficients have to be calculated only once for each trustee.
% % \end{algorithmic}
% % \end{algorithm} 

% At the end of the decryption phase we will be in possession of the \textit{raw result} of the election, i.e. the full list of votes in plain text (decrypted form).

% \subsubsection{Result Publication}
% The \textit{results module} is responsible for interpreting the \textit{raw result} and present the result of the election in a more readable way. The interpretation of the result is dependant on the election type (simple election, multiple election, STV, etc.).

% For simplicity, we will consider the simple election case, where voters had to choose one option from a predefined set of candidates.

% The \textit{Digital Ballot Box} $\mathcal{D}$ verifies every single vote from the list of raw results \( V_i \in \boldsymbol{V} \) and if it matches one of the vote options \( V_i \in \boldsymbol{M} \) the vote counter for that particular candidate is incremented. If a vote from the list of raw results does not correspond to any of the vote options \( V_i \not\in \boldsymbol{M} \), that represents an invalid vote and the counter of invalid votes is incremented. 

% Results will be published as a list of candidates next to the amount of votes they received, in decending order of the vote counter.