\subsubsection{Lying about your vote} Â´
This section describes why a voter is not able to prove how she voted to a third party verifier, after she has finished the voting process.

Note that, the vote cryptogram $e$ is actually equal to \( \mathbf{Enc}_{Y_\mathrm{enc}} (M, r_0 + r_1) \) out of which the voter does not know the value $r_0$. Therefore, the voter would only be able to prove the way she voted based on the empty cryptogram $e_0$ received from the server, but she cannot prove that $e_0$ is indeed an empty cryptogram. 

Instead, the voter is able to lie about her vote and generate fake evidence to support her claim. Based on the initial proof of empty cryptogram $PK_0$, the voter can lie about the cryptogram \(e = (R, C) \leftarrow \mathbf{Enc}_{Y_\mathrm{enc}} (M, r_0 + r_1) \) that it is an encryption of message \( M' \in \boldsymbol{M} \), with \( M' \neq M \) by computing a fake proof that will support her claim \( PK_0' \leftarrow \mathbf{VoteLie} (PK_0, M, M') \) (algorithm \ref{alg: vote lie}). Note that the voter has received both $e_0$ and $PK_0$ in the protocol from figure \ref{fig: vote cryptogram generation}.

% \begin{figure}
\begin{algorithm}[!h]
\DontPrintSemicolon
    \caption{\( \mathbf{VoteLie} (PK_0, M, M') \)}
    % \KwData{The encryption key \( Y_\mathrm{enc} \in E(\mathbb{F}_p) \)}
    \KwData{Proof of empty crypto \( PK_0 = (K_\mathrm{G}, K_\mathrm{Y}, c, z) \in E(\mathbb{F}_p)^2 \times \mathbb{Z}_q \times \mathbb{Z}_q \)}
    \KwMoreData{The original vote \( M \in E(\mathbb{F}_p) \)}
    \KwMoreData{The fake vote \( M' \in E(\mathbb{F}_p) \)}
    % \KwMoreData{The empty cryptogram \( e_0 = (R_0, C_0) \in \mathbb{E} \)}
    % \tcc{fabricate fake evidence that cryptogram \( e_\mathrm{f} = (R_0, C_0 + M - M') \) is empty}
    % \( C_\mathrm{f} \gets C_0 + M - M' \) \;
    % \( z_\mathrm{f} \gets \mathcal{H}(1 || C_\mathrm{f}) \) \;
    % \( \Delta_\mathrm{z} \gets z_\mathrm{f} - z_1 \) \tcp*{$z_1$ calculated in algorithm \ref{alg: Prove dlm}}
    \tcc{compute fake commitment}
    \( K_\mathrm{Y}' \gets K_\mathrm{Y} + [c](M' - M) \) \;
    \( PK_0' \gets (K_\mathrm{G}, K_\mathrm{Y}', c, z) \) \;
    \Return{\( PK_0' \)} \tcp*{\( PK_0' \in E(\mathbb{F}_p)^2 \times \mathbb{Z}_q \times \mathbb{Z}_q \)}
\end{algorithm}
% \end{figure}

% \begin{algorithm}[H]
% \floatname{algorithm}{Vote Lie}
% \renewcommand{\thealgorithm}{}
% \caption{Protocol for generating fake evidence}
% \begin{algorithmic}[1]
% \STATE Voter : Generates a proof of re-encryption \( PK_1 \leftarrow \mathbf{Prove}_{G, Y_\mathrm{enc}} (r_1) \)
% \STATE Voter : Fabricates a fake proof of empty encryption \( PK'_0 = (K'_0, c_0, s_0) \) for the cryptogram \( e'_0 = (R'_0, C'_0) = (R_0, C_0 + M - M') \)
% \STATE Voter : Computes \( \Delta_\mathrm{z} = z'_1 - z_1 \), where \( z'_1 = \mathcal{H}(1 || C'_0) \) and $z_1$ is calculated as in section \ref{multiple dle}
% \STATE Voter : Computes new commitment
% \[
% K'_0 = K_0 + [\Delta_\mathrm{z} \cdot s_0]Y - [c_0]([\Delta_\mathrm{z}]C_0 + [z'_1](M - M'))
% \]
% \end{algorithmic}
% \end{algorithm} 

The voter delivers the vote cryptogram $e = (R, C)$, the fake empty cryptogram \( e_0' = (R_0, C_0') \), where \( C_0' = C_0 + M - M' \), the fake proof of empty cryptogram $PK_0'$ and a proof of correct re-encryption \( PK \leftarrow \mathbf{ProveEquality}_{G, Y_\mathrm{enc}} (r_1) \) (algorithm \ref{alg: Prove dle}). To be convinced that the cryptogram $e$ contains vote $M'$ a verifier checks the proof of re-encryption \( \mathbf{VerifyEquality}_{G, Y_\mathrm{enc}} (PK, R - R_0, C - C_0' - M') \). If it validates, the verifier checks the second proof of empty cryptogram \( \mathbf{VerifyEquality}_{G, Y_\mathrm{enc}} \) \( (PK_0', R_0, C_0') \) (algorithm \ref{alg: Verify dle}). If both proofs validate, verifier is convinced about the fake evidence.

Therefore, because the voter is able to produce valid fake evidence about the way she voted, a voter should not be trusted for proving the way she voted regardless of the fact that she is honest or not.